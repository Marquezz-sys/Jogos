<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Menu com Rel√≥gio e Jogo da Cobrinha</title>
    <!-- Carrega o Tailwind CSS CDN para estiliza√ß√£o -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define que o corpo da p√°gina ocupa 100% da altura da viewport */
        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fundo escuro */
            padding: 16px; /* Espa√ßamento geral */
        }
        /* Estilos do Rel√≥gio */
        #clock-container {
            min-width: 280px;
        }
        /* Estilos personalizados para o Canvas do jogo */
        #gameCanvas {
            border: 4px solid #374151; /* Cor da borda escura */
            background-color: #1f2937; /* Fundo do jogo escuro */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            display: block;
            margin: 0 auto;
        }
        /* Garantir que o canvas seja fluido em telas menores */
        .game-area-wrapper {
            max-width: 400px;
            width: 100%;
            margin: 0 auto;
        }
        @media (max-width: 640px) {
            #gameCanvas {
                width: 100%;
                height: 100%;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center">

    <h1 class="text-4xl font-extrabold text-indigo-400 mb-10 mt-4 md:mt-0">Meu Painel Interativo</h1>

    <!-- Cont√™iner principal para alinhar os widgets lado a lado no desktop -->
    <div class="flex flex-col md:flex-row items-start md:items-center justify-center gap-10 w-full max-w-5xl">

        <!-- 1. REL√ìGIO DIGITAL (Mantido com o estilo legal) -->
        <div class="w-full md:w-auto flex-shrink-0 flex justify-center">
            <div id="clock-container" class="p-6 rounded-2xl shadow-2xl bg-gray-800 border-4 border-indigo-600 transform hover:scale-105 transition duration-300">
                <div class="text-xl font-semibold text-gray-400 mb-2">Rel√≥gio At√¥mico</div>
                <!-- Onde o hor√°rio ser√° exibido -->
                <div id="clock" class="text-6xl md:text-7xl font-extrabold text-indigo-400 tracking-wider">
                    --:--:--
                </div>
                <!-- Onde a data ser√° exibida -->
                <div id="date" class="text-lg md:text-xl text-gray-400 mt-2 text-center">
                    --/--/----
                </div>
            </div>
        </div>
        <!-- FIM DO REL√ìGIO -->

        <!-- 2. JOGO DA COBRINHA (Snake Game) -->
        <div id="game-widget" class="w-full md:w-1/2 flex flex-col items-center p-4 bg-gray-800 rounded-2xl shadow-2xl border-4 border-green-600">

            <h2 class="text-2xl font-bold text-green-400 mb-4">Jogo da Cobrinha üêç (Pontos Ilimitados)</h2>

            <!-- O BOT√ÉO SOLICITADO PARA INICIAR O JOGO -->
            <button id="startButton" class="
                bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-full shadow-lg
                transition duration-300 ease-in-out transform hover:scale-105 mb-6
                focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50
            ">
                üïπÔ∏è Come√ßar Jogo
            </button>

            <!-- √Årea de Mensagens (Game Over, etc.) -->
            <div id="messageBox" class="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-2 rounded-lg hidden mb-3 w-full max-w-xs mx-auto" role="alert">
                <p id="messageText" class="font-semibold text-sm"></p>
                <button id="closeMessage" class="mt-1 text-xs text-yellow-900 font-bold hover:underline">Fechar</button>
            </div>

            <!-- Placar -->
            <div class="flex justify-center mb-4 w-full">
                <div class="text-lg font-semibold text-gray-200 bg-gray-700 p-2 rounded-lg shadow-md">
                    Pontua√ß√£o: <span id="scoreDisplay" class="text-green-400 font-extrabold">0</span>
                </div>
            </div>

            <!-- Wrapper para garantir que o Canvas seja quadrado e responsivo -->
            <div class="game-area-wrapper">
                <!-- Canvas do Jogo -->
                <canvas id="gameCanvas" width="400" height="400" class="max-w-full"></canvas>
            </div>


            <!-- Controles de Toque (Vis√≠vel apenas em telas pequenas) -->
            <div id="touchControls" class="mt-4 md:hidden flex flex-col items-center justify-center space-y-2">
                <p class="text-gray-400 font-semibold text-sm">Controles (Toque)</p>
                <!-- Cima -->
                <button id="up" class="control-btn w-12 h-10 bg-gray-600 hover:bg-gray-500 text-white rounded-lg shadow-md transition duration-150 transform active:scale-95">‚¨ÜÔ∏è</button>
                <div class="flex space-x-2">
                    <!-- Esquerda -->
                    <button id="left" class="control-btn w-10 h-10 bg-gray-600 hover:bg-gray-500 text-white rounded-lg shadow-md transition duration-150 transform active:scale-95">‚¨ÖÔ∏è</button>
                    <!-- Baixo -->
                    <button id="down" class="control-btn w-12 h-10 bg-gray-600 hover:bg-gray-500 text-white rounded-lg shadow-md transition duration-150 transform active:scale-95">‚¨áÔ∏è</button>
                    <!-- Direita -->
                    <button id="right" class="control-btn w-10 h-10 bg-gray-600 hover:bg-gray-500 text-white rounded-lg shadow-md transition duration-150 transform active:scale-95">‚û°Ô∏è</button>
                </div>
            </div>
        </div>
        <!-- FIM DO JOGO DA COBRINHA -->

    </div>

    <script>
        // =================================================================
        // L√ìGICA DO REL√ìGIO DIGITAL
        // =================================================================

        // Fun√ß√£o para formatar n√∫meros para ter sempre dois d√≠gitos (ex: 09)
        function formatTime(n) {
            return n < 10 ? '0' + n : n;
        }

        // Fun√ß√£o principal que atualiza o rel√≥gio
        function updateClock() {
            const now = new Date();

            // Pega o hor√°rio atual
            const hours = formatTime(now.getHours());
            const minutes = formatTime(now.getMinutes());
            const seconds = formatTime(now.getSeconds());

            // Pega a data atual
            const day = formatTime(now.getDate());
            const month = formatTime(now.getMonth() + 1); // getMonth() √© baseado em zero (Janeiro = 0)
            const year = now.getFullYear();

            // Atualiza o elemento do rel√≥gio
            const clockElement = document.getElementById('clock');
            if (clockElement) {
                clockElement.textContent = `${hours}:${minutes}:${seconds}`;
            }

            // Atualiza o elemento da data
            const dateElement = document.getElementById('date');
            if (dateElement) {
                dateElement.textContent = `${day}/${month}/${year}`;
            }
        }

        // Chama a fun√ß√£o updateClock imediatamente para evitar um atraso inicial
        updateClock();

        // Configura o rel√≥gio para ser atualizado a cada 1000 milissegundos (1 segundo)
        setInterval(updateClock, 1000);


        // =================================================================
        // L√ìGICA DO JOGO DA COBRINHA
        // =================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startButton = document.getElementById('startButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const closeMessage = document.getElementById('closeMessage');
        const GRID_SIZE = 20; // Tamanho de cada c√©lula (bloco)
        let tileCount = canvas.width / GRID_SIZE; // N√∫mero de blocos em uma linha/coluna

        let snake = [];
        let foodX, foodY;
        let xVelocity = GRID_SIZE;
        let yVelocity = 0;
        let score = 0;
        let isPlaying = false;
        let gameLoopInterval;
        let nextX, nextY; // Usado para evitar movimentos opostos instant√¢neos

        // Cores
        const SNAKE_COLOR = '#4ADE80'; // Verde da cobrinha
        const FOOD_COLOR = '#F87171'; // Vermelho da comida

        // --- Fun√ß√µes de Estado e Inicializa√ß√£o ---

        /**
         * Exibe uma mensagem na caixa de alerta customizada.
         * @param {string} message - A mensagem a ser exibida.
         */
        function showMessage(message) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
            startButton.textContent = 'üîÅ Jogar Novamente';
            startButton.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-yellow-600', 'hover:bg-yellow-700');
            startButton.classList.add('bg-red-600', 'hover:bg-red-700');
        }

        /**
         * Inicializa as vari√°veis do jogo.
         */
        function initGame() {
            // Posi√ß√£o inicial da cabe√ßa da cobra no centro
            const centerX = Math.floor(tileCount / 2) * GRID_SIZE;
            const centerY = Math.floor(tileCount / 2) * GRID_SIZE;

            snake = [
                { x: centerX, y: centerY },
                { x: centerX - GRID_SIZE, y: centerY }, // Segundo segmento
                { x: centerX - 2 * GRID_SIZE, y: centerY }  // Terceiro segmento
            ];

            xVelocity = GRID_SIZE; // Come√ßa se movendo para a direita
            yVelocity = 0;
            score = 0;
            scoreDisplay.textContent = score;
            messageBox.classList.add('hidden');
            startButton.textContent = 'Pausar Jogo';
            startButton.classList.remove('bg-red-600', 'hover:bg-red-700', 'bg-blue-600', 'hover:bg-blue-700');
            startButton.classList.add('bg-yellow-600', 'hover:bg-yellow-700');

            placeFood();
            nextX = xVelocity;
            nextY = yVelocity;
            isPlaying = true;
        }

        /**
         * Coloca a comida em uma posi√ß√£o aleat√≥ria que n√£o esteja na cobra.
         */
        function placeFood() {
            let newFoodX, newFoodY;
            let collision;

            do {
                collision = false;
                // Gera coordenadas de bloco aleat√≥rias
                newFoodX = Math.floor(Math.random() * tileCount) * GRID_SIZE;
                newFoodY = Math.floor(Math.random() * tileCount) * GRID_SIZE;

                // Verifica colis√£o com a cobra
                for (const segment of snake) {
                    if (segment.x === newFoodX && segment.y === newFoodY) {
                        collision = true;
                        break;
                    }
                }
            } while (collision);

            foodX = newFoodX;
            foodY = newFoodY;
        }

        // --- L√≥gica do Jogo ---

        /**
         * Fun√ß√£o principal do loop do jogo.
         */
        function gameLoop() {
            if (!isPlaying) return;

            // Atualiza a velocidade antes de mover a cobra
            xVelocity = nextX;
            yVelocity = nextY;

            let headX = snake[0].x + xVelocity;
            let headY = snake[0].y + yVelocity;

            // 1. Verifica Colis√µes (Parede e Pr√≥pria Cobra)
            if (headX < 0 || headX >= canvas.width || headY < 0 || headY >= canvas.height) {
                // Colis√£o com a parede
                gameOver();
                return;
            }

            for (let i = 1; i < snake.length; i++) {
                if (headX === snake[i].x && headY === snake[i].y) {
                    // Colis√£o com o corpo
                    gameOver();
                    return;
                }
            }

            // 2. Adiciona a nova cabe√ßa
            const newHead = { x: headX, y: headY };
            snake.unshift(newHead);

            // 3. Verifica se comeu a comida
            if (headX === foodX && headY === foodY) {
                score++;
                scoreDisplay.textContent = score;
                placeFood(); // Coloca nova comida (n√£o remove a cauda, aumentando a cobra)
            } else {
                snake.pop(); // Remove a cauda se n√£o comeu a comida
            }

            // NOTA: Removido o limite de pontos. A l√≥gica acima permite pontua√ß√£o infinita
            // at√© o Game Over por colis√£o.

            // 4. Desenha tudo
            drawGame();
        }

        /**
         * Desenha todos os elementos do jogo: fundo, comida e cobra.
         */
        function drawGame() {
            // Limpa o Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Desenha a Comida
            ctx.fillStyle = FOOD_COLOR;
            ctx.beginPath();
            // Desenha um c√≠rculo para a comida para melhor est√©tica
            ctx.arc(foodX + GRID_SIZE / 2, foodY + GRID_SIZE / 2, GRID_SIZE / 2 * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Desenha a Cobra
            ctx.fillStyle = SNAKE_COLOR;
            snake.forEach((segment, index) => {
                // Corpo com bordas arredondadas e um pequeno espa√ßamento
                ctx.fillRect(segment.x + 1, segment.y + 1, GRID_SIZE - 2, GRID_SIZE - 2);

                // Desenha os olhos na cabe√ßa (√≠ndice 0)
                if (index === 0) {
                    ctx.fillStyle = '#000000'; // Preto
                    const eyeSize = GRID_SIZE / 6;
                    let eye1X = segment.x + (GRID_SIZE - eyeSize) / 3;
                    let eye1Y = segment.y + (GRID_SIZE - eyeSize) / 3;
                    let eye2X = segment.x + (GRID_SIZE - eyeSize) * 2 / 3;
                    let eye2Y = segment.y + (GRID_SIZE - eyeSize) * 2 / 3;

                    // Ajusta a posi√ß√£o dos olhos dependendo da dire√ß√£o
                    if (xVelocity > 0) { // Direita
                        eye1X = segment.x + GRID_SIZE - eyeSize * 2;
                        eye1Y = segment.y + eyeSize * 1.5;
                        eye2X = segment.x + GRID_SIZE - eyeSize * 2;
                        eye2Y = segment.y + GRID_SIZE - eyeSize * 2;
                    } else if (xVelocity < 0) { // Esquerda
                        eye1X = segment.x + eyeSize;
                        eye1Y = segment.y + eyeSize * 1.5;
                        eye2X = segment.x + eyeSize;
                        eye2Y = segment.y + GRID_SIZE - eyeSize * 2;
                    } else if (yVelocity > 0) { // Baixo
                        eye1X = segment.x + eyeSize * 1.5;
                        eye1Y = segment.y + GRID_SIZE - eyeSize * 2;
                        eye2X = segment.x + GRID_SIZE - eyeSize * 2;
                        eye2Y = segment.y + GRID_SIZE - eyeSize * 2;
                    } else if (yVelocity < 0) { // Cima
                        eye1X = segment.x + eyeSize * 1.5;
                        eye1Y = segment.y + eyeSize;
                        eye2X = segment.x + GRID_SIZE - eyeSize * 2;
                        eye2Y = segment.y + eyeSize;
                    }

                    // Desenha os dois olhos
                    ctx.fillRect(eye1X, eye1Y, eyeSize, eyeSize);
                    ctx.fillRect(eye2X, eye2Y, eyeSize, eyeSize);
                }
            });
        }

        /**
         * Encerra o jogo.
         */
        function gameOver() {
            isPlaying = false;
            clearInterval(gameLoopInterval);
            showMessage(`Fim de Jogo! Sua pontua√ß√£o final foi: ${score}`);
        }

        /**
         * Pausa ou despausa o jogo.
         */
        function togglePause() {
            if (!snake.length && !isPlaying) {
                // Se o jogo nunca come√ßou, inicia.
                startGame();
            } else if (isPlaying) {
                isPlaying = false;
                clearInterval(gameLoopInterval);
                startButton.textContent = '‚ñ∂Ô∏è Continuar Jogo';
                startButton.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-green-600', 'hover:bg-green-700');
                startButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Jogo Pausado. Clique em Continuar.');
            } else {
                isPlaying = true;
                gameLoopInterval = setInterval(gameLoop, 100); // Velocidade do jogo
                startButton.textContent = 'Pausar Jogo';
                startButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-red-600', 'hover:bg-red-700');
                startButton.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                messageBox.classList.add('hidden'); // Esconde a mensagem de pausa
            }
        }

        /**
         * Inicia o jogo (ou reinicia se for Game Over).
         */
        function startGame() {
             if (startButton.textContent.includes('Jogar Novamente') || !snake.length) {
                initGame();
                gameLoopInterval = setInterval(gameLoop, 100); // 100ms = 10 FPS
                startButton.textContent = 'Pausar Jogo';
                startButton.classList.remove('bg-red-600', 'hover:bg-red-700', 'bg-blue-600', 'hover:bg-blue-700', 'bg-green-600', 'hover:bg-green-700');
                startButton.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
             } else {
                togglePause();
             }
        }

        // --- Controles ---

        /**
         * Altera a dire√ß√£o da cobra.
         * @param {string} direction - A nova dire√ß√£o ('up', 'down', 'left', 'right').
         */
        function changeDirection(direction) {
            if (!isPlaying) return;

            switch (direction) {
                case 'up':
                    // Impede ir para baixo se estiver indo para cima (e vice-versa)
                    if (yVelocity === 0) {
                        nextX = 0;
                        nextY = -GRID_SIZE;
                    }
                    break;
                case 'down':
                    if (yVelocity === 0) {
                        nextX = 0;
                        nextY = GRID_SIZE;
                    }
                    break;
                case 'left':
                    if (xVelocity === 0) {
                        nextX = -GRID_SIZE;
                        nextY = 0;
                    }
                    break;
                case 'right':
                    if (xVelocity === 0) {
                        nextX = GRID_SIZE;
                        nextY = 0;
                    }
                    break;
            }
        }

        /**
         * Listener para teclas do teclado.
         * @param {KeyboardEvent} event
         */
        function keyPush(event) {
            event.preventDefault(); // Evita que a p√°gina role com as setas
            if (!isPlaying && event.key !== ' ') return; // N√£o aceita movimento se n√£o estiver jogando (exceto espa√ßo para pausar/iniciar)

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    changeDirection('up');
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    changeDirection('down');
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    changeDirection('left');
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    changeDirection('right');
                    break;
                case ' ': // Barra de espa√ßo para pausar/iniciar
                    togglePause();
                    break;
            }
        }

        // --- Configura√ß√£o Inicial e Event Listeners do Jogo ---

        // Eventos para o teclado
        document.addEventListener('keydown', keyPush);

        // Evento para o bot√£o de iniciar/pausar/reiniciar
        startButton.addEventListener('click', startGame);

        // Evento para fechar a caixa de mensagem
        closeMessage.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        // Eventos para os bot√µes de toque (mobile)
        document.getElementById('up').addEventListener('click', () => changeDirection('up'));
        document.getElementById('down').addEventListener('click', () => changeDirection('down'));
        document.getElementById('left').addEventListener('click', () => changeDirection('left'));
        document.getElementById('right').addEventListener('click', () => changeDirection('right'));

        // Ajusta o canvas e inicia o jogo ao carregar a janela
        window.addEventListener('load', function() {
            const wrapper = document.querySelector('.game-area-wrapper');

            // Calcula o tamanho m√°ximo quadrado baseado no wrapper (limitado a 400px)
            const newSize = Math.min(wrapper.offsetWidth, 400);

            // Garante que o tamanho seja um m√∫ltiplo de GRID_SIZE
            canvas.width = Math.floor(newSize / GRID_SIZE) * GRID_SIZE;
            canvas.height = canvas.width; // Quadrado
            tileCount = canvas.width / GRID_SIZE;

            // Desenha o fundo inicial
            drawGame();
            showMessage('Pressione "Come√ßar Jogo" ou ESPA√áO para come√ßar!');

            // Atualiza o rel√≥gio na inicializa√ß√£o
            updateClock();
        });

        // Adiciona um listener para redimensionamento para manter o canvas responsivo
        window.addEventListener('resize', () => {
            const wrapper = document.querySelector('.game-area-wrapper');
            const newSize = Math.min(wrapper.offsetWidth, 400);

            const oldWidth = canvas.width;
            const newCanvasSize = Math.floor(newSize / GRID_SIZE) * GRID_SIZE;

            if (newCanvasSize !== oldWidth) {
                canvas.width = newCanvasSize;
                canvas.height = newCanvasSize;
                tileCount = canvas.width / GRID_SIZE;

                // Se o jogo estiver rodando, pausa e avisa sobre o redimensionamento
                if (gameLoopInterval) {
                    clearInterval(gameLoopInterval);
                }
                if (isPlaying) {
                    isPlaying = false;
                    startButton.textContent = '‚ñ∂Ô∏è Continuar Jogo';
                    startButton.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                    startButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    showMessage('O tamanho da tela mudou. Clique em Continuar para retomar!');
                } else if (!snake.length) {
                    // Se estiver na tela inicial, apenas redesenha o fundo e a mensagem
                    drawGame();
                }
            }
        });

    </script>
</body>
</html>
