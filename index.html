<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Cobrinha Retro</title>
    <!-- Inclui a biblioteca p5.js para o jogo -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    <!-- Inclui o Tailwind CSS para o estilo do rel√≥gio e da interface -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Importa a fonte retr√¥ (VT323) para o jogo e t√≠tulos */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        /* Importa a fonte Inter para o rel√≥gio digital */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'VT323', monospace;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
            flex-direction: column;

            /* Necess√°rio para posicionar o pseudo-elemento de fundo */
            position: relative;
            background-color: #1a202c; /* Cor de fundo de fallback/base */
        }

        /* Pseudo-elemento para o fundo da p√°gina (Imagem com filtro) */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Usando a imagem carregada */
            background-image: url('uploaded:image_bb8868.png-2577ce53-c52d-4631-a115-5157a8977ef6');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            z-index: -1; /* Coloca a imagem atr√°s de todo o conte√∫do */

            /* Filtros para garantir visibilidade do texto */
            filter: brightness(1.5) blur(2px) contrast(1.1);
        }

        /* Estilo da borda do canvas do jogo */
        main {
            border: 4px solid #4a5568;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.3s ease;
        }
        /* Efeito de brilho ao focar (simulando a fruta) */
        main:focus-within {
             box-shadow: 0 0 30px rgba(255, 176, 58, 0.7);
        }
        .instructions {
            margin-top: 1.5rem;
            color: #a0aec0;
            font-size: 1.5rem;
            text-align: center;
            text-shadow: 1px 1px 2px #000;
        }

        /* Estilos da Vis√£o do Rel√≥gio */
        #clock-view {
            width: 100%;
            height: 100vh;
            display: none; /* Escondido por padr√£o */
            font-family: 'Inter', sans-serif; /* Usar Inter para o rel√≥gio */
            /* Fundo com um gradiente */
            background: linear-gradient(135deg, #a7b7c2, #5a6d7a);
        }
        #clock-view .clock-container {
             /* Centraliza o rel√≥gio dentro da view */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        /* Anima√ß√£o do sapo */
        @keyframes dance {
            0%, 100% { transform: translateY(0); }
            25% { transform: translateY(-5px) rotate(5deg); }
            50% { transform: translateY(0) rotate(-5deg); }
            75% { transform: translateY(-5px) rotate(5deg); }
        }
        #sapo {
            animation: dance 1s infinite alternate;
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen">

    <!-- 1. Vis√£o do Jogo (p5.js Canvas) e Menu -->
    <div id="game-view" class="flex flex-col items-center">
        <!-- O p5.js ir√° injetar o canvas dentro desta tag <main> -->
        <main id="main"></main>
        <!-- Instru√ß√µes de movimento, vis√≠vel apenas no modo Jogo -->
        <div id="game-instructions" class="instructions" style="display: none;">
            Use as setas ou **WASD** para mover a cobrinha!
        </div>
    </div>

    <!-- 2. Vis√£o do Rel√≥gio (HTML puro) -->
    <div id="clock-view">
        <div class="clock-container">
            <div class="flex flex-col md:flex-row items-center p-8 bg-gray-800 rounded-2xl shadow-lg border-2 border-gray-700 max-w-lg w-full mx-4">

                <!-- Sapo dan√ßante animado -->
                <div id="sapo" class="text-6xl md:text-8xl mb-4 md:mb-0 md:mr-6">
                    üê∏
                </div>

                <div class="flex flex-col items-center">
                    <h1 class="text-3xl font-bold mb-4 text-center">Hor√°rio de Bras√≠lia</h1>
                    <div id="relogio" class="text-6xl md:text-7xl font-mono font-bold text-green-400">
                        00:00:00
                    </div>
                    <p class="mt-4 text-sm text-gray-400 text-center">A hora √© atualizada a cada segundo.</p>
                </div>
            </div>

            <!-- Bot√£o de Voltar ao Menu -->
            <button id="back-to-menu-btn" onclick="showView('menu')"
                class="mt-8 px-6 py-3 bg-red-600 text-white font-bold rounded-xl shadow-lg transition duration-300 hover:bg-red-700 hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-50">
                VOLTAR AO MENU
            </button>
        </div>
    </div>

    <script>
        // =======================================================
        // VARI√ÅVEIS GLOBAIS E ESTADO DO JOGO
        // =======================================================
        let s; ¬† ¬† ¬†
        let food; ¬† ¬†
        let scl = 20;
        let score = 0;
        let isGameOver = false;
        const WIN_SCORE = 10; // Pontua√ß√£o necess√°ria para vencer

        // Limites dos bot√µes desenhados no p5.js (para detec√ß√£o de clique)
        let winButtonBounds = null;
        let menuGameButtonBounds = null;
        let menuClockButtonBounds = null;

        // Vari√°vel para controlar a visualiza√ß√£o atual. Inicia em 'menu'.
        let currentView = 'menu'; // 'menu', 'game', 'game_over', 'win', 'clock'

        // Vari√°vel para armazenar o intervalo de atualiza√ß√£o do rel√≥gio
        let clockInterval;

        // =======================================================
        // FUN√á√ïES DE GERENCIAMENTO DE VISTA (VIEW)
        // =======================================================

        /**
         * Alterna a visualiza√ß√£o entre o menu/jogo (p5.js) e o rel√≥gio (HTML).
         */
        function showView(viewName) {
            currentView = viewName;
            const gameView = document.getElementById('game-view');
            const clockView = document.getElementById('clock-view');
            const gameInstructions = document.getElementById('game-instructions');

            if (viewName === 'clock') {
                gameView.style.display = 'none';
                clockView.style.display = 'flex';
                // Garante que o rel√≥gio est√° a funcionar
                initClock();
            } else {
                gameView.style.display = 'flex';
                clockView.style.display = 'none';

                // Exibe as instru√ß√µes de movimento apenas quando o jogo estiver ativo
                gameInstructions.style.display = (viewName === 'game') ? 'block' : 'none';

                // Reinicia o jogo ao voltar para o menu ou iniciar o jogo
                if (viewName === 'menu' || viewName === 'game') {
                    resetGame();
                }
            }
        }

        /**
         * Inicializa o rel√≥gio digital, definindo a hora de Bras√≠lia.
         */
        function initClock() {
            // Limpa o intervalo anterior para evitar m√∫ltiplos loops
            if (clockInterval) clearInterval(clockInterval);

            function atualizarRelogio() {
                const relogioElemento = document.getElementById('relogio');
                if (relogioElemento) {
                    // Usando a API de Data para obter o tempo em S√£o Paulo/Bras√≠lia
                    const agora = new Date();
                    const opcoes = {
                        timeZone: 'America/Sao_Paulo',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    };
                    const horarioBrasilia = agora.toLocaleTimeString('pt-BR', opcoes);
                    relogioElemento.textContent = horarioBrasilia;
                }
            }

            atualizarRelogio();
            clockInterval = setInterval(atualizarRelogio, 1000);
        }

        // =======================================================
        // FUN√á√ïES DO P5.JS (SETUP, DRAW, EVENTOS)
        // =======================================================

        /**
         * Inicializa o p5.js e o canvas.
         */
        function setup() {
            // Define o tamanho do canvas para ser responsivo (m√°ximo 640x480)
            const canvasWidth = Math.min(window.innerWidth - 32, 640);
            const canvasHeight = Math.min(window.innerHeight - 100, 480);
            const canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('main');

            // Define a taxa de quadros (velocidade do jogo)
            frameRate(10);
            resetGame();

            // Inicia o jogo na tela do menu
            showView('menu');

            // Inicia o loop do rel√≥gio para que ele esteja sempre atualizado em segundo plano
            initClock();
        }

        /**
         * Fun√ß√£o de loop principal do p5.js.
         */
        function draw() {
            // Fundo do canvas do JOGO: Cor s√≥lida escura (Dark Gray/Blue-ish)
            // Se estiver no Menu, o background ser√° transparente para mostrar a imagem de fundo do BODY
            if (currentView === 'menu') {
                background(45, 55, 72, 0);
                drawMenuScreen();
            } else {
                background(45, 55, 72); // Fundo s√≥lido para as telas de jogo/fim/vit√≥ria

                if (currentView === 'game') {
                    // --- L√≥gica do Jogo Ativo ---
                    s.update();
                    s.checkDeath();

                    drawFood();

                    if (s.eat(food)) {
                        score++;
                        pickLocation();
                    }

                    s.show();
                    drawScore();

                    // Verifica a condi√ß√£o de vit√≥ria
                    if (score >= WIN_SCORE) {
                        currentView = 'win';
                    }
                } else if (currentView === 'game_over') {
                    drawGameOverScreen();
                } else if (currentView === 'win') {
                    drawWinScreen();
                }
            }
        }

        /**
         * Fun√ß√£o chamada a cada toque de tecla (WASD/Setas para movimento, ESPA√áO para Menu/In√≠cio).
         */
        function keyPressed() {
            // Se estiver no rel√≥gio, ignorar
            if (currentView === 'clock') return;

            // ESPA√áO (32) sempre trata in√≠cio/rein√≠cio/menu
            if (keyCode === 32) {
                if (currentView === 'menu') {
                    showView('game');
                    return;
                }
                if (currentView === 'game_over' || currentView === 'win') {
                    showView('menu');
                    return;
                }
            }

            // Movimento s√≥ se estiver no jogo ativo
            if (currentView === 'game') {
                switch (keyCode) {
                    case UP_ARROW:
                    case 87: // W (Cima)
                        s.dir(0, -1);
                        break;
                    case DOWN_ARROW:
                    case 83: // S (Baixo)
                        s.dir(0, 1);
                        break;
                    case LEFT_ARROW:
                    case 65: // A (Esquerda)
                        s.dir(-1, 0);
                        break;
                    case RIGHT_ARROW:
                    case 68: // D (Direita)
                        s.dir(1, 0);
                        break;
                }
            }
        }

        /**
         * Verifica cliques do mouse nos bot√µes desenhados no p5.js (Menu e Vit√≥ria).
         */
        function mouseClicked() {
            // Fun√ß√£o auxiliar para verificar se o mouse est√° sobre o bot√£o
            const isOver = (bounds) => {
                return mouseX > bounds.x &&
                       mouseX < bounds.x + bounds.w &&
                       mouseY > bounds.y &&
                       mouseY < bounds.y + bounds.h;
            };

            // Clicar nos bot√µes do Menu
            if (currentView === 'menu') {
                if (menuGameButtonBounds && isOver(menuGameButtonBounds)) {
                    showView('game');
                } else if (menuClockButtonBounds && isOver(menuClockButtonBounds)) {
                    showView('clock');
                }
            }

            // Clicar no bot√£o "VER REL√ìGIO" na tela de vit√≥ria
            if (currentView === 'win' && winButtonBounds && isOver(winButtonBounds)) {
                showView('clock');
            }
        }

        /**
         * Ajusta o canvas quando a janela √© redimensionada.
         */
        function windowResized() {
             // S√≥ redimensiona o canvas se a vista n√£o for 'clock'
            if (currentView !== 'clock') {
                const newWidth = Math.min(window.innerWidth - 32, 640);
                const newHeight = Math.min(window.innerHeight - 100, 480);
                resizeCanvas(newWidth, newHeight);
                // Gera nova localiza√ß√£o para a comida ap√≥s redimensionamento
                pickLocation();
            }
        }

        // =======================================================
        // FUN√á√ïES DO JOGO (COBRINHA E COMIDA)
        // =======================================================

        /**
         * Reinicia o estado do jogo.
         */
        function resetGame() {
            s = new Snake();
            isGameOver = false;
            score = 0;
            // Centraliza a cobrinha no in√≠cio do jogo
            let centerX = floor(width / (2 * scl)) * scl;
            let centerY = floor(height / (2 * scl)) * scl;
            s.x = centerX;
            s.y = centerY;
            s.dir(1, 0); // Come√ßa movendo para a direita
            pickLocation();

            // Limpa os limites dos bot√µes p5.js ao reiniciar
            winButtonBounds = null;
            menuGameButtonBounds = null;
            menuClockButtonBounds = null;
        }

        /**
         * Escolhe um local aleat√≥rio para a comida, garantindo que n√£o colida com a cobrinha.
         */
        function pickLocation() {
            let cols = floor(width / scl);
            let rows = floor(height / scl);

            // Escolhe um local aleat√≥rio na grade
            food = createVector(floor(random(cols)), floor(random(rows)));
            food.mult(scl);

            // Verifica se a comida colidiu com a cauda da cobra
            for (let i = 0; i < s.tail.length; i++) {
                if (food.x === s.tail[i].x && food.y === s.tail[i].y) {
                    pickLocation(); // Tenta novamente
                    return;
                }
            }
        }

        // =======================================================
        // FUN√á√ïES DE DESENHO (DRAW SCREENS)
        // =======================================================

        /**
         * Desenha o Menu Principal (Estilo Bloco).
         */
        function drawMenuScreen() {
            const btnSize = 140;
            const gap = 30;
            const totalWidth = 2 * btnSize + gap;
            const startX = width / 2 - totalWidth / 2;
            const btnY = height / 2 - btnSize / 2 + 30;
            const cornerRadius = 20;
            const shadowOffset = 10;

            // T√≠tulo Principal
            textSize(50);
            textAlign(CENTER, CENTER);
            fill(0, 0, 0, 150); // Sombra do t√≠tulo
            text('SELECIONE UMA OP√á√ÉO', width / 2 + 3, btnY - 120 + 3);
            fill(255, 255, 150); // T√≠tulo principal (Amarelo claro)
            text('SELECIONE UMA OP√á√ÉO', width / 2, btnY - 120);

            // --- Bloco JOGO DA COBRINHA (Esquerda) ---
            const gameBtnX = startX;
            menuGameButtonBounds = { x: gameBtnX, y: btnY, w: btnSize, h: btnSize };

            // Desenho do Bot√£o (Sombra e Principal)
            fill(40, 160, 100); // Sombra (Verde Escuro)
            rect(gameBtnX, btnY + shadowOffset, btnSize, btnSize, cornerRadius);
            fill(66, 225, 153); // Principal (Verde brilhante)
            rect(gameBtnX, btnY, btnSize, btnSize, cornerRadius);

            // Conte√∫do (√çcone e Texto)
            textSize(50);
            fill(45, 55, 72); // Cor do texto/√≠cone
            text('üêç', gameBtnX + btnSize / 2, btnY + btnSize * 0.4);
            textSize(18);
            text('JOGO DA', gameBtnX + btnSize / 2, btnY + btnSize * 0.7);
            text('COBRINHA', gameBtnX + btnSize / 2, btnY + btnSize * 0.85);


            // --- Bloco VER REL√ìGIO (Direita) ---
            const clockBtnX = startX + btnSize + gap;
            menuClockButtonBounds = { x: clockBtnX, y: btnY, w: btnSize, h: btnSize };

            // Desenho do Bot√£o (Sombra e Principal)
            fill(40, 90, 150); // Sombra (Azul Escuro)
            rect(clockBtnX, btnY + shadowOffset, btnSize, btnSize, cornerRadius);
            fill(66, 153, 225); // Principal (Azul suave)
            rect(clockBtnX, btnY, btnSize, btnSize, cornerRadius);

            // Conte√∫do (√çcone e Texto)
            textSize(50);
            fill(45, 55, 72);
            text('‚è∞', clockBtnX + btnSize / 2, btnY + btnSize * 0.4);
            textSize(18);
            text('VER', clockBtnX + btnSize / 2, btnY + btnSize * 0.7);
            text('REL√ìGIO', clockBtnX + btnSize / 2, btnY + btnSize * 0.85);

            // Instru√ß√£o de atalho
            textSize(22);
            fill(180, 255, 180);
            text('Pressione ESPA√áO para Iniciar o Jogo R√°pido', width / 2, btnY + btnSize + 70);
        }

        /**
         * Desenha a tela de fim de jogo (GAME OVER).
         */
        function drawGameOverScreen() {
            textSize(48);
            fill(255, 50, 50); // Vermelho para GAME OVER
            textAlign(CENTER, CENTER);
            text('FIM DE JOGO!', width / 2, height / 2 - 40);

            textSize(28);
            fill(255, 255, 255);
            text('Pontua√ß√£o Final: ' + score, width / 2, height / 2 + 10);

            textSize(24);
            fill(150, 200, 255);
            text('Pressione ESPA√áO para ir para o Menu', width / 2, height / 2 + 50);
        }

        /**
         * Desenha a tela de vit√≥ria.
         */
        function drawWinScreen() {
            textSize(48);
            fill(150, 255, 150); // Verde brilhante para Vit√≥ria
            textAlign(CENTER, CENTER);
            text('VOC√ä VENCEU!', width / 2, height / 2 - 60);

            textSize(28);
            fill(255);
            text('Pontua√ß√£o Final: ' + score, width / 2, height / 2 - 10);

            // --- Desenho do Bot√£o "VER REL√ìGIO" ---

            let btnW = 300;
            let btnH = 45;
            let btnX = width / 2 - btnW / 2;
            let btnY = height / 2 + 50;

            // Armazena as dimens√µes do bot√£o para detec√ß√£o de clique
            winButtonBounds = { x: btnX, y: btnY, w: btnW, h: btnH };

            // Bot√£o background (Azul suave)
            fill(66, 153, 225);
            rect(btnX, btnY, btnW, btnH, 8);

            // Bot√£o texto
            textSize(22);
            fill(255);
            textAlign(CENTER, CENTER);
            text('VER REL√ìGIO', width / 2, btnY + btnH / 2 + 3);

            // Instru√ß√£o alternativa de rein√≠cio (SPACE)
            textSize(18);
            fill(200, 255, 255);
            text('Ou Pressione ESPA√áO para ir para o Menu', width / 2, height / 2 + 120);
        }

        /**
         * Desenha a comida (quadrado laranja com efeito de perspectiva).
         */
        function drawFood() {
            // Efeito de perspectiva: Comida no topo √© menor, no rodap√© √© maior
            let perspectiveFactor = map(food.y, 0, height, 0.8, 1.2);
            let foodSize = scl * perspectiveFactor;

            fill(255, 176, 58); // Laranja claro/amarelo para a fruta
            noStroke();
            rectMode(CORNER);
            rect(food.x, food.y, foodSize, foodSize, 5);
        }

        /**
         * Desenha a pontua√ß√£o no canto superior direito.
         */
        function drawScore() {
            textSize(28);
            fill(255, 255, 255);
            textAlign(RIGHT, TOP);
            text('PONTOS: ' + score, width - 10, 10);
        }

        // =======================================================
        // CLASSE COBRINHA (SNAKE)
        // =======================================================

        /**
         * Construtor do objeto Snake (Cobrinha).
         */
        function Snake() {
            this.x = 0;
            this.y = 0;
            this.xspeed = 1;
            this.yspeed = 0;
            this.total = 0; // Comprimento da cauda
            this.tail = []; // Array da cauda

            /**
             * Define a dire√ß√£o da cobrinha, impedindo o movimento reverso imediato.
             */
            this.dir = function(x, y) {
                // Impede que a cobra se mova na dire√ß√£o oposta √† sua dire√ß√£o atual
                if (this.xspeed === -x && x !== 0) return;
                if (this.yspeed === -y && y !== 0) return;

                this.xspeed = x;
                this.yspeed = y;
            }

            /**
             * Verifica se a cobrinha comeu a comida.
             */
            this.eat = function(pos) {
                // Verifica a colis√£o (dist√¢ncia menor que 1, j√° que est√£o na grade)
                let d = dist(this.x, this.y, pos.x, pos.y);
                if (d < 1) {
                    this.total++;
                    return true;
                } else {
                    return false;
                }
            }

            /**
             * Atualiza a posi√ß√£o e a cauda da cobrinha.
             */
            this.update = function() {
                // Adiciona a posi√ß√£o atual (cabe√ßa) √† cauda
                this.tail.push(createVector(this.x, this.y));

                // Se a cauda for maior que o total (tamanho da cobrinha), remove o √∫ltimo elemento
                if (this.tail.length > this.total) {
                    this.tail.shift();
                }

                // Move a cabe√ßa da cobrinha
                this.x = this.x + this.xspeed * scl;
                this.y = this.y + this.yspeed * scl;
            }

            /**
             * Verifica se a cobrinha colidiu com a parede ou com a pr√≥pria cauda.
             */
            this.checkDeath = function() {
                // Colis√£o com as paredes
                if (this.x >= width || this.x < 0 || this.y >= height || this.y < 0) {
                    currentView = 'game_over';
                    return;
                }

                // Colis√£o com a pr√≥pria cauda
                for (let i = 0; i < this.tail.length; i++) {
                    let pos = this.tail[i];
                    let d = dist(this.x, this.y, pos.x, pos.y);
                    if (this.total > 0 && d < 1) {
                        currentView = 'game_over';
                        return;
                    }
                }
            }

            /**
             * Desenha a cobrinha na tela.
             */
            this.show = function() {
                noStroke();
                rectMode(CORNER);

                // Desenha o corpo com um efeito de escurecimento (alfa) na cauda
                for (let i = 0; i < this.tail.length; i++) {
                    let pos = this.tail[i];
                    // Aplica o fator de perspectiva no tamanho do segmento
                    let perspectiveFactor = map(pos.y, 0, height, 0.8, 1.2);
                    let segmentSize = scl * perspectiveFactor;
                    // Segmentos mais antigos s√£o mais transparentes
                    let alpha = map(i, 0, this.tail.length - 1, 150, 255);

                    fill(255, 140, 0, alpha); // Laranja Escuro/Corpo
                    rect(pos.x, pos.y, segmentSize, segmentSize, 3);
                }

                // Desenha a cabe√ßa
                let headPerspectiveFactor = map(this.y, 0, height, 0.8, 1.2);
                let headSize = scl * headPerspectiveFactor;
                fill(255, 140, 0); // Laranja Escuro S√≥lido/Cabe√ßa
                rect(this.x, this.y, headSize, headSize, 3);

                // Desenha os "olhos" pretos
                fill(0);
                let eyeSize = headSize * 0.15;
                if (this.xspeed === 1) { // Direita
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.3, eyeSize);
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.7, eyeSize);
                } else if (this.xspeed === -1) { // Esquerda
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.3, eyeSize);
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.7, eyeSize);
                } else if (this.yspeed === 1) { // Baixo
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.7, eyeSize);
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.7, eyeSize);
                } else if (this.yspeed === -1) { // Cima
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.3, eyeSize);
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.3, eyeSize);
                }
            }
        }
    </script>
</body>
</html>