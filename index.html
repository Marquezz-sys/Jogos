<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Cobrinha (p5.js)</title>
    <!-- Inclui a biblioteca p5.js -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    <!-- Inclui o Tailwind CSS para o estilo do rel칩gio e da interface -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Importa a fonte retr칪 para o jogo */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        /* Importa a fonte Inter para o rel칩gio */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'VT323', monospace;
            background-color: #1a202c; /* Fundo escuro */
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
            flex-direction: column;
        }
        main {
            /* Estilo para a 치rea do canvas do jogo */
            border: 4px solid #4a5568;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.3s ease;
        }
        main:focus-within {
             /* Brilho da cor da fruta ajustado */
             box-shadow: 0 0 30px rgba(255, 176, 58, 0.7);
        }
        .instructions {
            margin-top: 1.5rem;
            color: #a0aec0;
            font-size: 1.5rem;
            text-align: center;
            text-shadow: 1px 1px 2px #000;
        }

        /* Estilos do rel칩gio */
        #clock-view {
            width: 100%;
            height: 100vh;
            display: none; /* Escondido por padr칚o */
            font-family: 'Inter', sans-serif; /* Usar Inter para o rel칩gio */
            /* Fundo com um gradiente suave para uma apar칡ncia mais agrad치vel */
            background: linear-gradient(135deg, #a7b7c2, #5a6d7a);
        }
        #clock-view .clock-container {
             /* Centraliza o rel칩gio dentro da view */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        @keyframes dance {
            0%, 100% { transform: translateY(0); }
            25% { transform: translateY(-5px) rotate(5deg); }
            50% { transform: translateY(0) rotate(-5deg); }
            75% { transform: translateY(-5px) rotate(5deg); }
        }

        #sapo {
            animation: dance 1s infinite alternate;
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen">

    <!-- 1. Vis칚o do Jogo (p5.js Canvas) -->
    <div id="game-view" class="flex flex-col items-center">
        <!-- O p5.js ir치 injetar o canvas dentro desta tag <main> -->
        <main id="main"></main>
        <!-- Instru칞칫es atualizadas -->
        <div class="instructions">Use as setas ou **WASD** para mover a cobrinha!</div>
    </div>

    <!-- 2. Vis칚o do Rel칩gio (HTML puro) -->
    <div id="clock-view">
        <div class="clock-container">
            <div class="flex flex-col md:flex-row items-center p-8 bg-gray-800 rounded-2xl shadow-lg border-2 border-gray-700 max-w-lg w-full mx-4">

                <!-- Sapo dan칞ante -->
                <div id="sapo" class="text-6xl md:text-8xl mb-4 md:mb-0 md:mr-6">
                    游냦
                </div>

                <div class="flex flex-col items-center">
                    <h1 class="text-3xl font-bold mb-4 text-center">Hor치rio de Bras칤lia</h1>
                    <div id="relogio" class="text-6xl md:text-7xl font-mono font-bold text-green-400">
                        00:00:00
                    </div>
                    <p class="mt-4 text-sm text-gray-400 text-center">A hora 칠 atualizada a cada segundo.</p>
                </div>
            </div>

            <!-- Bot칚o de Voltar ao Jogo -->
            <button id="back-to-game-btn" onclick="showView('splash')"
                class="mt-8 px-6 py-3 bg-red-600 text-white font-bold rounded-xl shadow-lg transition duration-300 hover:bg-red-700 hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-50">
                VOLTAR AO JOGO
            </button>
        </div>
    </div>

    <script>
        // Vari치veis globais do jogo
        let s;
        let food;
        let scl = 20;
        let score = 0;
        let isGameOver = false;
        const WIN_SCORE = 10;
        let winButtonBounds = null;

        // NOVO: Vari치vel para controlar a visualiza칞칚o atual
        let currentView = 'splash'; // 'splash', 'game', 'game_over', 'win', 'clock'

        // Vari치vel para armazenar o intervalo de atualiza칞칚o do rel칩gio
        let clockInterval;

        /**
         * Alterna a visualiza칞칚o entre o jogo e o rel칩gio.
         */
        function showView(viewName) {
            currentView = viewName;
            const gameView = document.getElementById('game-view');
            const clockView = document.getElementById('clock-view');

            if (viewName === 'clock') {
                gameView.style.display = 'none';
                clockView.style.display = 'flex';
                // Garante que o rel칩gio est치 a funcionar
                initClock();
            } else {
                gameView.style.display = 'flex';
                clockView.style.display = 'none';
                // Para o jogo na tela inicial
                if (viewName === 'splash') {
                    resetGame();
                }
            }
        }

        /**
         * Inicializa o p5.js e o jogo.
         */
        function setup() {
            // Define o tamanho do canvas para ser responsivo, mas com um m치ximo
            const canvasWidth = Math.min(window.innerWidth - 32, 640);
            const canvasHeight = Math.min(window.innerHeight - 100, 480);
            const canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('main');

            frameRate(10);
            resetGame();

            // Inicia o jogo na tela de abertura
            showView('splash');

            // Inicia o loop do rel칩gio para que ele esteja sempre atualizado
            initClock();
        }

        /**
         * L칩gica de inicializa칞칚o do rel칩gio digital (do c칩digo fornecido pelo usu치rio).
         */
        function initClock() {
            if (clockInterval) clearInterval(clockInterval);

            function atualizarRelogio() {
                const relogioElemento = document.getElementById('relogio');
                if (relogioElemento) {
                    const agora = new Date();
                    const opcoes = {
                        timeZone: 'America/Sao_Paulo',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    };
                    const horarioBrasilia = agora.toLocaleTimeString('pt-BR', opcoes);
                    relogioElemento.textContent = horarioBrasilia;
                }
            }

            atualizarRelogio();
            clockInterval = setInterval(atualizarRelogio, 1000);
        }

        /**
         * Reinicia o estado do jogo.
         */
        function resetGame() {
            s = new Snake();
            isGameOver = false;
            score = 0;
            winButtonBounds = null;

            let centerX = floor(width / (2 * scl)) * scl;
            let centerY = floor(height / (2 * scl)) * scl;
            s.x = centerX;
            s.y = centerY;
            s.dir(1, 0);

            pickLocation();
        }

        /**
         * Fun칞칚o de loop do p5.js.
         */
        function draw() {
            background(45, 55, 72);

            // O desenho s칩 acontece se a visualiza칞칚o for 'game' ou 'win' ou 'game_over'
            if (currentView === 'game') {
                // L칩gica do jogo
                s.update();
                s.checkDeath();

                drawFood();

                if (s.eat(food)) {
                    score++;
                    pickLocation();
                }

                s.show();
                drawScore();

                // Verifica a condi칞칚o de vit칩ria
                if (score >= WIN_SCORE) {
                    currentView = 'win';
                }
            }

            if (currentView === 'splash') {
                drawSplashScreen();
            } else if (currentView === 'game_over') {
                drawGameOverScreen();
            } else if (currentView === 'win') {
                drawWinScreen();
            }
        }

        /**
         * Desenha a tela de abertura.
         */
        function drawSplashScreen() {
            textSize(64);
            fill(255, 255, 255);
            textAlign(CENTER, CENTER);
            text('JOGO DA COBRINHA', width / 2, height / 2 - 80);

            textSize(36);
            fill(150, 255, 150);
            text('Pressione ESPA칂O para come칞ar o jogo', width / 2, height / 2 + 20);

            textSize(20);
            fill(100, 150, 200);
            text('Use as setas ou WASD para se mover.', width / 2, height / 2 + 80);
        }

        /**
         * Desenha a tela de fim de jogo.
         */
        function drawGameOverScreen() {
            textSize(48);
            fill(255, 255, 255);
            textAlign(CENTER, CENTER);
            text('FIM DE JOGO!', width / 2, height / 2 - 40);

            textSize(28);
            text('Pontua칞칚o Final: ' + score, width / 2, height / 2 + 10);

            textSize(24);
            fill(150, 200, 255);
            text('Pressione ESPA칂O para Reiniciar', width / 2, height / 2 + 50);
        }

        /**
         * Desenha a tela de vit칩ria, incluindo o bot칚o de "pr칩ximo jogo".
         */
        function drawWinScreen() {
            textSize(48);
            fill(150, 255, 150);
            textAlign(CENTER, CENTER);
            text('VOC칅 VENCEU!', width / 2, height / 2 - 60);

            textSize(28);
            fill(255);
            text('Pontua칞칚o Final: ' + score, width / 2, height / 2 - 10);

            // --- Desenho do Bot칚o "VER REL칍GIO" ---

            let btnW = 300;
            let btnH = 45;
            let btnX = width / 2 - btnW / 2;
            let btnY = height / 2 + 50;

            // Armazena as dimens칫es do bot칚o para detec칞칚o de clique
            winButtonBounds = { x: btnX, y: btnY, w: btnW, h: btnH };

            // Bot칚o background (Azul suave)
            fill(66, 153, 225);
            rect(btnX, btnY, btnW, btnH, 8);

            // Bot칚o texto
            textSize(22);
            fill(255);
            textAlign(CENTER, CENTER);
            text('VER REL칍GIO', width / 2, btnY + btnH / 2 + 3);

            // Instru칞칚o alternativa de rein칤cio (SPACE)
            textSize(18);
            fill(200, 255, 255);
            text('Ou Pressione ESPA칂O para Jogar Novamente', width / 2, height / 2 + 120);
        }

        /**
         * Desenha a comida.
         */
        function drawFood() {
            let perspectiveFactor = map(food.y, 0, height, 0.8, 1.2);
            let foodSize = scl * perspectiveFactor;

            fill(255, 176, 58); // Laranja Ligeiramente Mais Escuro (#FFB03A)
            noStroke();
            rectMode(CORNER);
            rect(food.x, food.y, foodSize, foodSize, 5);
        }

        /**
         * Desenha a pontua칞칚o.
         */
        function drawScore() {
            textSize(28);
            fill(255, 255, 255);
            textAlign(RIGHT, TOP);
            text('PONTOS: ' + score, width - 10, 10);
        }

        /**
         * Construtor do objeto Snake (Cobrinha).
         */
        function Snake() {
            this.x = 0;
            this.y = 0;
            this.xspeed = 1;
            this.yspeed = 0;
            this.total = 0;
            this.tail = [];

            this.dir = function(x, y) {
                if (this.xspeed === -x && x !== 0) return;
                if (this.yspeed === -y && y !== 0) return;

                this.xspeed = x;
                this.yspeed = y;
            }

            this.eat = function(pos) {
                let d = dist(this.x, this.y, pos.x, pos.y);
                if (d < 1) {
                    this.total++;
                    return true;
                } else {
                    return false;
                }
            }

            this.update = function() {
                this.tail.push(createVector(this.x, this.y));

                if (this.tail.length > this.total) {
                    this.tail.shift();
                }

                this.x = this.x + this.xspeed * scl;
                this.y = this.y + this.yspeed * scl;
            }

            this.checkDeath = function() {
                if (this.x >= width || this.x < 0 || this.y >= height || this.y < 0) {
                    isGameOver = true;
                    currentView = 'game_over'; // Atualiza o estado
                    return;
                }

                for (let i = 0; i < this.tail.length; i++) {
                    let pos = this.tail[i];
                    let d = dist(this.x, this.y, pos.x, pos.y);
                    if (this.total > 0 && d < 1) {
                        isGameOver = true;
                        currentView = 'game_over'; // Atualiza o estado
                        return;
                    }
                }
            }

            this.show = function() {
                noStroke();
                rectMode(CORNER);

                // Desenha o corpo
                for (let i = 0; i < this.tail.length; i++) {
                    let pos = this.tail[i];
                    let perspectiveFactor = map(pos.y, 0, height, 0.8, 1.2);
                    let segmentSize = scl * perspectiveFactor;
                    let alpha = map(i, 0, this.tail.length - 1, 150, 255);

                    fill(255, 140, 0, alpha); // Laranja Escuro (#FF8C00)
                    rect(pos.x, pos.y, segmentSize, segmentSize, 3);
                }

                // Desenha a cabe칞a
                let headPerspectiveFactor = map(this.y, 0, height, 0.8, 1.2);
                let headSize = scl * headPerspectiveFactor;
                fill(255, 140, 0); // Laranja Escuro (#FF8C00)
                rect(this.x, this.y, headSize, headSize, 3);

                // Desenha os "olhos"
                fill(0);
                let eyeSize = headSize * 0.15;
                if (this.xspeed === 1) {
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.3, eyeSize);
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.7, eyeSize);
                } else if (this.xspeed === -1) {
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.3, eyeSize);
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.7, eyeSize);
                } else if (this.yspeed === 1) {
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.7, eyeSize);
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.7, eyeSize);
                } else if (this.yspeed === -1) {
                    ellipse(this.x + headSize * 0.3, this.y + headSize * 0.3, eyeSize);
                    ellipse(this.x + headSize * 0.7, this.y + headSize * 0.3, eyeSize);
                }
            }
        }

        /**
         * Escolhe um local aleat칩rio para a comida.
         */
        function pickLocation() {
            let cols = floor(width / scl);
            let rows = floor(height / scl);

            food = createVector(floor(random(cols)), floor(random(rows)));
            food.mult(scl);

            for (let i = 0; i < s.tail.length; i++) {
                if (food.x === s.tail[i].x && food.y === s.tail[i].y) {
                    pickLocation();
                    return;
                }
            }
        }

        /**
         * Fun칞칚o chamada a cada toque de tecla.
         */
        function keyPressed() {
            // Se estiver no rel칩gio, ignorar
            if (currentView === 'clock') return;

            // ESPA칂O (32) sempre trata in칤cio/rein칤cio
            if (keyCode === 32) {
                if (currentView === 'splash') {
                    showView('game');
                    return;
                }
                if (currentView === 'game_over' || currentView === 'win') {
                    showView('splash');
                    return;
                }
            }

            // Movimento s칩 se estiver no jogo ativo
            if (currentView === 'game') {
                switch (keyCode) {
                    case UP_ARROW:
                    case 87: // W (Cima)
                        s.dir(0, -1);
                        break;
                    case DOWN_ARROW:
                    case 83: // S (Baixo)
                        s.dir(0, 1);
                        break;
                    case LEFT_ARROW:
                    case 65: // A (Esquerda)
                        s.dir(-1, 0);
                        break;
                    case RIGHT_ARROW:
                    case 68: // D (Direita)
                        s.dir(1, 0);
                        break;
                }
            }
        }

        /**
         * Verifica cliques do mouse.
         */
        function mouseClicked() {
            // Clicar no bot칚o "VER REL칍GIO"
            if (currentView === 'win' && winButtonBounds) {
                if (
                    mouseX > winButtonBounds.x &&
                    mouseX < winButtonBounds.x + winButtonBounds.w &&
                    mouseY > winButtonBounds.y &&
                    mouseY < winButtonBounds.y + winButtonBounds.h
                ) {
                    showView('clock');
                }
            }
        }


        /**
         * Ajusta o canvas quando a janela 칠 redimensionada.
         */
        function windowResized() {
             // S칩 redimensiona o canvas se a vista n칚o for 'clock'
            if (currentView !== 'clock') {
                const newWidth = Math.min(window.innerWidth - 32, 640);
                const newHeight = Math.min(window.innerHeight - 100, 480);
                resizeCanvas(newWidth, newHeight);
                pickLocation();
            }
        }
    </script>
</body>
</html>