<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Menu e Jogos Integrados</title>
    <!-- Carrega o Tailwind CSS para estiliza√ß√£o moderna e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define a fonte, fundo escuro global e garante o m√≠nimo de altura */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark navy background */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        /* --- ESTILOS DO NOVO MENU ESCURO (FUNDO DO CARD E T√çTULO) --- */

        /* Ajuste do container principal do menu */
        #main-menu-view {
            background-color: #2c2c4a; /* Fundo do card mais claro */
            border: 1px solid #4a4a75;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        /* Estilo para o t√≠tulo brilhante */
        .glow-title {
            color: #ffeb3b; /* Amarelo */
            text-shadow:
                0 0 5px rgba(255, 235, 59, 0.8), /* Brilho suave */
                0 0 10px rgba(0, 0, 0, 0.8), /* Sombra escura para defini√ß√£o */
                1px 1px 1px #000000; /* Sombra dura */
            font-weight: 800;
            letter-spacing: 2px;
        }

        /* Estilo dos bot√µes de op√ß√£o do menu (Visual 3D) */
        .menu-option-btn {
            width: 140px;
            height: 140px;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            transition: transform 0.1s, box-shadow 0.1s;
            position: relative;
            border: none;
            cursor: pointer;
            text-align: center;
            padding: 1rem;

            /* Simula eleva√ß√£o 3D */
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.5);
            transform: translateY(0);
        }

        .menu-option-btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.5);
        }

        .menu-option-btn .icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.5));
        }

        .btn-green {
            background-color: #38c172; /* Teal/Green */
            color: #1a1a1a;
        }
        .btn-blue {
            background-color: #4a8df6; /* Bright Blue */
            color: #1a1a1a;
        }

        /* Estilo para o texto da instru√ß√£o */
        .instruction-text {
            color: #b0c4de; /* Azul claro/cinza */
            text-shadow: 1px 1px 1px #000;
            font-weight: 500;
        }

        /* Estilo para o Rel√≥gio/Data (widget) */
        #clock-widget {
            background-color: #3f305e; /* Fundo roxo escuro */
            border: 2px solid #8e44ad; /* Borda roxa vibrante */
            box-shadow: 0 0 15px rgba(142, 68, 173, 0.5);
        }
        #clock-widget .time {
            color: #c0c0f0; /* Azul claro/roxo */
            text-shadow: 0 0 10px rgba(142, 68, 173, 0.8);
        }
        #clock-widget .date {
            color: #999;
        }


        /* --- ESTILOS DO JOGO DE DAMAS (EXISTENTE) --- */

        /* Estilo da casa do tabuleiro */
        .casa {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
        }

        /* Cores das casas */
        .casa.clara { background-color: #f0d2b4; } /* Cor para casas onde n√£o h√° jogo */
        .casa.escura { background-color: #b58863; } /* Cor onde o jogo acontece */

        /* Estilo da pe√ßa BASE */
        .peca {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(0, 0, 0, 0.2);
            position: relative;
        }

        /* Estilos Din√¢micos das Pe√ßas */
        .peca.peca-branca {
            background-color: #ffffff;
            border-color: #a0a0a0;
            box-shadow: 0 0 0 2px #fff, 0 3px 6px rgba(0, 0, 0, 0.4);
        }
        .peca.peca-preta {
            background-color: #2c2c2c;
            border-color: #1a1a1a;
            box-shadow: 0 0 0 2px #333, 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        /* DAMA (Rei) */
        .peca.dama::after {
            content: 'üëë'; /* √çcone de coroa para representar a Dama */
            font-size: 1.2rem;
            position: absolute;
            color: gold;
            text-shadow: 1px 1px 2px #000;
        }

        /* Efeitos de Intera√ß√£o */
        .peca:hover { transform: scale(1.05); }
        .selecionada { outline: 3px solid #f97316; outline-offset: 1px; } /* Laranja vibrante */
        .movimento-valido { background-color: #10b981 !important; cursor: pointer; } /* Verde para movimentos */
        .movimento-valido:hover { filter: brightness(1.2); }

        /* Estilo do tabuleiro em si (Grid para 8x8) */
        #tabuleiro {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            grid-template-rows: repeat(8, minmax(0, 1fr));
            border: 4px solid #4a5568;
            aspect-ratio: 1 / 1; /* Garante que √© um quadrado */
            max-width: 500px;
            width: 95vw;
        }

        /* --- ESTILOS DO JOGO DA COBRINHA (SNAKE) --- */
        #snake-game-view {
            background-color: #1e1e3f; /* Fundo escuro para a tela de jogo */
        }
        #snake-canvas {
            background-color: #0d1117; /* Fundo do grid do jogo */
            border: 2px solid #5a5a8a;
            box-shadow: 0 0 15px rgba(100, 100, 150, 0.5);
            margin-top: 1rem;
            max-width: 500px;
            width: 95vw;
            aspect-ratio: 1 / 1;
        }
        #snake-score-display {
            font-size: 1.5rem;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        /* --- Estilos do Top Menu (ajustados para o tema escuro) --- */
        #top-menu {
            background-color: #1f2937; /* Dark Gray */
            color: white;
            padding: 0.75rem 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        }
        .menu-btn {
            background-color: #4a4a75; /* Darker buttons in the top bar */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        .menu-btn:hover {
            background-color: #666699;
            transform: translateY(-1px);
        }
        .menu-btn.active {
            background-color: #f97316; /* Orange-500 */
        }

        /* Responsividade geral */
        @media (min-width: 768px) {
            #tabuleiro, #snake-canvas { max-width: 600px; }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center">

    <!-- 1. BARRA DE NAVEGA√á√ÉO / MENU -->
    <nav id="top-menu" class="w-full sticky top-0 z-10 flex justify-center">
        <div class="flex space-x-4 max-w-4xl w-full">
            <!-- BOT√ÉO IN√çCIO (Menu Principal) -->
            <button class="menu-btn" onclick="showView('main-menu-view')">IN√çCIO</button>
            <!-- BOT√ÉO DAMAS -->
            <button id="btn-damas-menu" class="menu-btn" onclick="showView('checkers-view')">DAMAS</button>
            <!-- BOT√ÉO COBRINHA -->
            <button id="btn-snake-menu" class="menu-btn" onclick="showView('snake-game-view'); resizeCanvas(); resetGame();">COBRINHA</button>
        </div>
    </nav>

    <!-- 2. CONTAINER PRINCIPAL (Centralizado na tela) -->
    <div class="w-full flex-grow flex flex-col items-center p-4">

        <!-- 2a. TELA DO MENU PRINCIPAL (COM COBRINHA E REL√ìGIO) -->
        <div id="main-menu-view" class="w-full max-w-sm rounded-xl shadow-2xl p-8 hidden flex flex-col items-center">

            <!-- Widget de Rel√≥gio/Data -->
            <div id="clock-widget" class="p-4 mb-10 rounded-xl flex flex-col items-center">
                <p id="clock-time" class="time text-5xl font-extrabold">12:00:00</p>
                <p id="clock-date" class="date text-sm mt-1">01/01/2025</p>
            </div>

            <h1 class="glow-title text-4xl text-center mb-10">
                SELECIONE UMA OP√á√ÉO
            </h1>

            <div class="flex justify-center space-x-6 mb-10">
                <!-- JOGO DA COBRINHA -->
                <button class="menu-option-btn btn-green" onclick="showView('snake-game-view'); startGame();">
                    <span class="icon">üêç</span>
                    <span class="text-base font-bold">JOGAR</span>
                </button>
                <!-- VER REL√ìGIO (Apenas um placeholder, j√° que o widget est√° vis√≠vel) -->
                <button class="menu-option-btn btn-blue" onclick="alert('O rel√≥gio j√° est√° vis√≠vel!')">
                    <span class="icon">‚è∞</span>
                    <span class="text-base font-bold">VER REL√ìGIO</span>
                </button>
            </div>

            <p class="instruction-text text-center text-sm">
                Pressione <strong class="font-extrabold text-white">ESPA√áO</strong> para Iniciar o Jogo R√°pido (Cobrinha)
            </p>
        </div>

        <!-- 2b. TELA DO JOGO DA COBRINHA (SNAKE) -->
        <div id="snake-game-view" class="w-full max-w-lg rounded-xl shadow-2xl p-6 hidden flex-col items-center">
            <h1 class="text-3xl font-extrabold text-white text-center mb-4">Jogo da Cobrinha</h1>
            <p id="snake-score-display" class="text-xl font-semibold text-green-400 mb-4">Pontua√ß√£o: 0</p>

            <canvas id="snake-canvas" width="400" height="400" class="rounded-lg"></canvas>

            <div id="snake-message" class="text-center mt-4">
                <p class="text-gray-300">Use as setas ou **WASD** para mover a cobrinha!</p>
                <button id="snake-start-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-200 mt-4">
                    INICIAR JOGO
                </button>
            </div>
        </div>

        <!-- 2c. TELA DO JOGO DE DAMAS (CHECKERS) -->
        <div id="checkers-view" class="w-full max-w-lg bg-white rounded-xl shadow-2xl p-6 mb-6 hidden">

            <!-- Conte√∫do do Jogo de Damas (Capa/Sele√ß√£o de Modo) -->
            <div id="tela-capa">
                 <h1 class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-red-500 text-center mb-6 border-b-2 pb-2 border-gray-200">
                    O Jogo de Damas
                </h1>

                <p class="text-xl font-semibold text-gray-700 mb-6 text-center">
                    Selecione sua cor e modo de jogo:
                </p>

                <!-- Sele√ß√£o de Cor -->
                <div class="mb-10">
                    <h2 class="text-center text-xl font-bold mb-5 text-gray-800">Sua Cor (VOC√ä)</h2>
                    <div class="flex justify-center space-x-6">
                        <!-- Escolher Brancas -->
                        <button id="select-white" data-color="white" class="btn-cor shadow-md bg-white text-black selected flex flex-col items-center">
                            <span class="font-semibold text-base mb-2">Brancas</span>
                            <div class="peca peca-branca w-10 h-10 pointer-events-none"></div>
                        </button>
                        <!-- Escolher Pretas -->
                        <button id="select-black" data-color="black" class="btn-cor shadow-md bg-gray-800 text-white flex flex-col items-center">
                            <span class="font-semibold text-base mb-2">Pretas</span>
                            <div class="peca peca-preta w-10 h-10 pointer-events-none"></div>
                        </button>
                    </div>
                </div>

                <!-- Sele√ß√£o de Modo -->
                <div class="flex flex-col space-y-4">
                    <button id="btn-2v2-capa" class="flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 shadow-xl text-lg">
                        <span class="mr-3">üë•</span> 2 Jogadores (PvP)
                    </button>
                    <button id="btn-bot-capa" class="flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 shadow-xl text-lg">
                        <span class="mr-3">ü§ñ</span> Contra Bot (PvBot)
                    </button>
                </div>
            </div>

            <!-- Conte√∫do do Jogo (Inicialmente oculto) -->
            <div id="conteudo-jogo" class="hidden">

                <h1 class="text-3xl font-extrabold text-gray-800 text-center mb-4">
                    <span id="player-status-title" class="text-lg font-normal text-gray-500 block">Voc√™ joga com: Brancas</span>
                    Jogo de Damas
                </h1>

                <!-- Display de Pontua√ß√£o -->
                <div id="score-display" class="flex justify-around text-center mb-4 p-3 rounded-lg bg-gray-50 border border-gray-200">
                    <div class="score-j1">
                        <p class="text-sm font-semibold text-blue-600">Voc√™ comeu:</p>
                        <p id="score-j1-count" class="text-2xl font-bold text-gray-800">0</p>
                    </div>
                    <div class="score-j2">
                        <p class="text-sm font-semibold text-red-600">Advers√°rio comeu:</p>
                        <p id="score-j2-count" class="text-2xl font-bold text-gray-800">0</p>
                    </div>
                </div>
                <!-- Exibi√ß√£o de Status -->
                <div class="text-center p-3 rounded-lg border-2 border-gray-200">
                    <p id="status-jogo" class="text-lg font-bold text-gray-700">Turno de Brancas.</p>
                </div>
            </div>
             <!-- Tabuleiro de Jogo (Oculto inicialmente) -->
            <div id="tabuleiro" class="hidden">
                <!-- As casas do tabuleiro s√£o geradas pelo JavaScript -->
            </div>
        </div>

    </div>

    <!-- Modal de Fim de Jogo Damas (Oculto inicialmente) -->
    <div id="modal-fim-jogo" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-sm">
            <h2 id="modal-titulo" class="text-3xl font-bold mb-4 text-green-600"></h2>
            <p id="modal-mensagem" class="text-lg mb-6 text-gray-700"></p>
            <button id="btn-reiniciar-damas" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-200">
                Novo Jogo
            </button>
        </div>
    </div>

    <!-- Modal de Fim de Jogo Cobrinha (Oculto inicialmente) -->
    <div id="snake-modal-fim-jogo" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-sm">
            <h2 class="text-3xl font-bold mb-4 text-red-600">FIM DE JOGO</h2>
            <p id="snake-final-score" class="text-lg mb-6 text-gray-700 font-bold"></p>
            <button id="btn-reiniciar-snake" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-200">
                Tentar Novamente
            </button>
        </div>
    </div>


<script>
    // --- L√ìGICA DE GERENCIAMENTO DE VIS√ÉO (MENU/JOGO) ---
    const menuView = document.getElementById('main-menu-view');
    const checkersView = document.getElementById('checkers-view');
    const snakeView = document.getElementById('snake-game-view');
    const tabuleiroEl = document.getElementById('tabuleiro');
    const menuButtons = document.querySelectorAll('.menu-btn');

    function showView(viewId) {
        // Para a Cobrinha e Esconde o Tabuleiro de Damas
        stopSnakeGame();
        tabuleiroEl.classList.add('hidden');

        // Esconde todas as vistas principais
        menuView.classList.add('hidden', 'flex');
        checkersView.classList.add('hidden');
        snakeView.classList.add('hidden', 'flex-col');

        // Remove destaque de todos os bot√µes do menu
        menuButtons.forEach(btn => btn.classList.remove('active'));

        if (viewId === 'main-menu-view') {
            menuView.classList.remove('hidden');
            menuView.classList.add('flex');
            document.querySelector('#top-menu button:nth-child(1)').classList.add('active');
        } else if (viewId === 'checkers-view') {
            checkersView.classList.remove('hidden');
            document.getElementById('btn-damas-menu').classList.add('active');
            setupDamasInitial(); // Garante que a capa do jogo esteja vis√≠vel se for re-selecionado
        } else if (viewId === 'snake-game-view') {
            snakeView.classList.remove('hidden');
            snakeView.classList.add('flex-col');
            document.getElementById('btn-snake-menu').classList.add('active');
            resizeCanvas(); // Garante que o canvas da cobrinha esteja no tamanho correto
        }
    }

    // Define a vista inicial (para come√ßar no menu, seguindo a est√©tica do usu√°rio)
    window.onload = () => {
        showView('main-menu-view');
        updateClock();
        setInterval(updateClock, 1000);
        setupDamasInitial(); // Configura listeners de Damas, mas a view est√° oculta
        resizeCanvas(); // Inicializa o tamanho da Cobrinha
        resetGame(); // Prepara o estado inicial da Cobrinha
    };

    // --- WIDGET REL√ìGIO ---
    function updateClock() {
        const now = new Date();
        const timeEl = document.getElementById('clock-time');
        const dateEl = document.getElementById('clock-date');

        const timeString = now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const dateString = now.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });

        timeEl.textContent = timeString;
        dateEl.textContent = dateString;
    }

    // Adiciona o listener para o atalho de teclado (Pressione ESPA√áO) no menu principal
    document.addEventListener('keydown', (e) => {
        if (!menuView.classList.contains('hidden') && e.code === 'Space') {
            e.preventDefault();
            // Inicia o JOGO DA COBRINHA (Jogo R√°pido)
            showView('snake-game-view');
            startGame();
        }
    });


    // =========================================================================
    //                            JOGO DA COBRINHA (SNAKE)
    // =========================================================================

    const canvas = document.getElementById('snake-canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('snake-start-btn');
    const scoreDisplay = document.getElementById('snake-score-display');
    const messageEl = document.getElementById('snake-message');
    const modalSnakeEl = document.getElementById('snake-modal-fim-jogo');
    const modalSnakeScoreEl = document.getElementById('snake-final-score');
    const restartSnakeBtn = document.getElementById('btn-reiniciar-snake');

    const tileCount = 20; // Grid de 20x20
    let tileSize;
    let snake = [];
    let apple = {};
    let xVelocity = 1;
    let yVelocity = 0;
    let score = 0;
    let gameLoopInterval;
    let isGameRunning = false;
    let isInputBlocked = false; // Para evitar movimentos duplos ou revers√£o imediata

    // Ajusta o tamanho do canvas para ser responsivo e calcula o tamanho dos tiles
    function resizeCanvas() {
        // Pega o tamanho real do elemento HTML no layout
        const containerSize = Math.min(canvas.parentElement.offsetWidth - 32, 500); // 500px max ou 95vw (considerando padding)

        // Define o tamanho do canvas para ser um quadrado
        canvas.width = containerSize;
        canvas.height = containerSize;

        // Recalcula o tamanho de cada tile (pe√ßa da cobrinha)
        tileSize = canvas.width / tileCount;

        // Se o jogo estiver rodando, redesenha imediatamente
        if (isGameRunning) {
             drawGame();
        } else {
             drawInitialScreen(); // Desenha a tela inicial se o jogo estiver parado
        }
    }
    window.addEventListener('resize', resizeCanvas);

    // Desenha a tela inicial (Cobrinha pequena e ma√ß√£)
    function drawInitialScreen() {
         ctx.fillStyle = '#0d1117';
         ctx.fillRect(0, 0, canvas.width, canvas.height);

         // Desenha a cobrinha inicial (para visualiza√ß√£o no menu)
         ctx.fillStyle = '#4cc9f0';
         snake.forEach(segment => {
            ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize - 1, tileSize - 1);
        });

         // Desenha a ma√ß√£ inicial
        ctx.fillStyle = '#ff4d6d';
        ctx.fillRect(apple.x * tileSize, apple.y * tileSize, tileSize - 1, tileSize - 1);
    }

    function resetGame() {
        stopSnakeGame(); // Garante que o loop anterior parou
        snake = [{ x: 10, y: 10 }]; // Posi√ß√£o inicial no centro
        apple = { x: 5, y: 5 }; // Ma√ß√£ em posi√ß√£o inicial
        xVelocity = 1;
        yVelocity = 0;
        score = 0;
        isInputBlocked = false;
        isGameRunning = false;

        scoreDisplay.textContent = `Pontua√ß√£o: 0`;
        messageEl.innerHTML = '<p class="text-gray-300">Use as setas ou **WASD** para mover a cobrinha!</p>';
        startBtn.classList.remove('hidden');

        drawInitialScreen(); // Desenha o canvas inicial
        hideSnakeModal();
    }

    // Cria uma nova posi√ß√£o para a ma√ß√£, garantindo que n√£o colida com a cobrinha
    function createApple() {
        let newApplePosition;
        do {
            newApplePosition = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount)
            };
        } while (snake.some(segment => segment.x === newApplePosition.x && segment.y === newApplePosition.y));
        apple = newApplePosition;
    }

    // Desenha o jogo (fundo, cobrinha, ma√ß√£)
    function drawGame() {
        // Fundo (Grid)
        ctx.fillStyle = '#0d1117';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Ma√ß√£
        ctx.fillStyle = '#ff4d6d'; // Cor da Ma√ß√£ (Rosa/Vermelho)
        ctx.fillRect(apple.x * tileSize, apple.y * tileSize, tileSize - 1, tileSize - 1);

        // Cobrinha (Percorre do corpo para a cabe√ßa)
        ctx.fillStyle = '#4cc9f0'; // Cor da Cobrinha (Ciano)
        snake.forEach((segment, index) => {
            // Desenha a cabe√ßa ligeiramente diferente, se desejar (opcional)
            if (index === 0) {
                 ctx.fillStyle = '#00f7ff'; // Cor da cabe√ßa
            } else {
                 ctx.fillStyle = '#4cc9f0';
            }
            ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize - 1, tileSize - 1);
        });
    }

    // L√≥gica principal do jogo (chamada em loop)
    function updateGame() {
        // Atualiza a posi√ß√£o da cabe√ßa da cobra
        let head = { x: snake[0].x + xVelocity, y: snake[0].y + yVelocity };

        // 1. Checa colis√£o com parede
        if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
            endGame("A cobrinha bateu na parede!");
            return;
        }

        // 2. Checa colis√£o com corpo (come√ßa a checar do segundo segmento)
        if (snake.some((segment, index) => index > 0 && segment.x === head.x && segment.y === head.y)) {
            endGame("A cobrinha mordeu o pr√≥prio rabo!");
            return;
        }

        // Adiciona nova cabe√ßa
        snake.unshift(head);

        // 3. Checa se comeu a ma√ß√£
        if (head.x === apple.x && head.y === apple.y) {
            score++;
            scoreDisplay.textContent = `Pontua√ß√£o: ${score}`;
            createApple(); // Cria nova ma√ß√£
        } else {
            // Remove o rabo (movimento normal)
            snake.pop();
        }

        drawGame();
        isInputBlocked = false; // Libera o input ap√≥s o tick do jogo
    }

    // Inicia o loop do jogo
    function startGame() {
        if (isGameRunning) return;
        isGameRunning = true;

        resetGame(); // Reinicia o estado
        createApple();
        startBtn.classList.add('hidden');
        messageEl.textContent = 'Mantenha-se em movimento!';

        // Define a velocidade do jogo (1000 / 100ms = 10 FPS)
        gameLoopInterval = setInterval(updateGame, 100);
    }

    // Para o loop do jogo
    function stopSnakeGame() {
        if (gameLoopInterval) {
            clearInterval(gameLoopInterval);
            gameLoopInterval = null;
        }
        isGameRunning = false;
    }

    // Finaliza o jogo e mostra o modal
    function endGame(reason) {
        stopSnakeGame();
        modalSnakeScoreEl.innerHTML = `<p class="mb-2 text-xl text-red-700">${reason}</p>Sua pontua√ß√£o final foi: <span class="text-3xl text-red-700">${score}</span>`;
        modalSnakeEl.classList.remove('hidden');
        modalSnakeEl.classList.add('flex');
    }

    function hideSnakeModal() {
        modalSnakeEl.classList.add('hidden');
        modalSnakeEl.classList.remove('flex');
    }

    // Event Listeners Snake
    startBtn.addEventListener('click', startGame);
    restartSnakeBtn.addEventListener('click', () => {
        hideSnakeModal();
        // N√£o inicia automaticamente, volta para a tela de 'INICIAR JOGO'
        resetGame();
    });

    // Lida com a entrada do teclado
    document.addEventListener('keydown', (e) => {
        // S√≥ aceita input se o jogo estiver rodando E a tela da cobrinha estiver ativa E o input n√£o estiver bloqueado
        if (!isGameRunning || snakeView.classList.contains('hidden') || isInputBlocked) return;

        let newX = xVelocity;
        let newY = yVelocity;

        switch (e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                // Impede reverter (se movendo para baixo, n√£o pode ir para cima)
                if (yVelocity !== 1) { newX = 0; newY = -1; isInputBlocked = true; }
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                // Impede reverter (se movendo para cima, n√£o pode ir para baixo)
                if (yVelocity !== -1) { newX = 0; newY = 1; isInputBlocked = true; }
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                // Impede reverter (se movendo para a direita, n√£o pode ir para a esquerda)
                if (xVelocity !== 1) { newX = -1; newY = 0; isInputBlocked = true; }
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                // Impede reverter (se movendo para a esquerda, n√£o pode ir para a direita)
                if (xVelocity !== -1) { newX = 1; newY = 0; isInputBlocked = true; }
                break;
        }

        // Aplica as novas velocidades se o movimento for permitido
        xVelocity = newX;
        yVelocity = newY;
    });

    // =========================================================================
    //                            JOGO DE DAMAS (CHECKERS)
    // =========================================================================

    // --- VARI√ÅVEIS GLOBAIS E ESTADO DO JOGO ---

    // Configura√ß√µes do jogo:
    const VAZIO = 0;
    const JOGADOR_1 = 1; ¬† ¬† ¬†// Jogador Humano (sempre controla as pe√ßas de baixo, R5-R7)
    const JOGADOR_2 = 2; ¬† ¬† ¬†// Oponente (sempre controla as pe√ßas de cima, R0-R2)
    const DAMA_1 = 3; ¬† ¬† ¬† ¬† // Dama do Jogador Humano
    const DAMA_2 = 4; ¬† ¬† ¬† ¬† // Dama do Oponente

    let board = [];
    let turnoAtual = JOGADOR_1;
    let modoJogo = null; // 'PVP' ou 'PVBOT'
    let pecaSelecionada = null;
    let capturasObrigatorias = [];
    let multiJumpPeca = null;
    let isGameOver = false;

    // Define a cor visual que o JOGADOR_1 est√° usando (true = Brancas)
    let userColorIsWhite = true;

    // Rastreamento de pontua√ß√£o (pe√ßas capturadas)
    let pecasCapturadasJ1 = 0; // Capturas feitas pelo JOGADOR 1 (Voc√™)
    let pecasCapturadasJ2 = 0; // Capturas feitas pelo JOGADOR 2 (Advers√°rio/Bot)

    // Elementos do DOM - Damas
    const statusEl = document.getElementById('status-jogo');
    const modalEl = document.getElementById('modal-fim-jogo');
    const modalTituloEl = document.getElementById('modal-titulo');
    const modalMensagemEl = document.getElementById('modal-mensagem');
    const scoreJ1El = document.getElementById('score-j1-count');
    const scoreJ2El = document.getElementById('score-j2-count');

    const telaCapaEl = document.getElementById('tela-capa');
    const conteudoJogoEl = document.getElementById('conteudo-jogo');
    const playerStatusTitleEl = document.getElementById('player-status-title');

    // --- INICIALIZA√á√ÉO E CONTROLES DE MODO DAMAS ---

    // Inicializa o estado do tabuleiro com a disposi√ß√£o inicial
    function inicializarBoard() {
        board = Array(8).fill(0).map(() => Array(8).fill(VAZIO));

        pecasCapturadasJ1 = 0;
        pecasCapturadasJ2 = 0;

        // Pe√ßas do JOGADOR_2 (em cima)
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 8; c++) {
                if ((r + c) % 2 !== 0) {
                    board[r][c] = JOGADOR_2;
                }
            }
        }

        // Pe√ßas do JOGADOR_1 (em baixo)
        for (let r = 5; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if ((r + c) % 2 !== 0) {
                    board[r][c] = JOGADOR_1;
                }
            }
        }
    }

    // Fun√ß√£o principal para iniciar o jogo em um modo espec√≠fico
    function iniciarJogoDamas(mode) {
        modoJogo = mode;
        isGameOver = false;
        inicializarBoard();

        // Esconde a capa e mostra o conte√∫do do jogo/tabuleiro
        telaCapaEl.classList.add('hidden');
        conteudoJogoEl.classList.remove('hidden');
        tabuleiroEl.classList.remove('hidden');

        // Se o jogador 1 (humano) escolheu Pretas, ele come√ßa de SEGUNDO.
        // Se o jogador 1 (humano) escolheu Brancas, ele come√ßa de PRIMEIRO.
        turnoAtual = userColorIsWhite ? JOGADOR_1 : JOGADOR_2;

        renderizarTabuleiro();
        pecaSelecionada = null;
        multiJumpPeca = null;
        capturasObrigatorias = checkAllCaptures(turnoAtual); // Capturas para quem realmente come√ßa
        esconderModalDamas();
        atualizarStatus();
        renderizarPontuacao();

        // Atualiza a cor exibida no t√≠tulo do jogo
        const cor = userColorIsWhite ? 'Brancas' : 'Pretas';
        playerStatusTitleEl.textContent = `Voc√™ joga com: ${cor}`;

        // Se o Bot for o primeiro a jogar
        if (modoJogo === 'PVBOT' && turnoAtual === JOGADOR_2) {
             setTimeout(fazerJogadaBot, 1000);
        }
    }

    // --- Configura√ß√£o da Capa e Event Listeners Damas ---
    function setupDamasInitial() {
        // Por padr√£o, esconde o tabuleiro e mostra a capa (dentro da CheckersView)
        tabuleiroEl.classList.add('hidden');
        conteudoJogoEl.classList.add('hidden');
        telaCapaEl.classList.remove('hidden');

        // L√≥gica de sele√ß√£o de cor na capa
        const selectWhiteEl = document.getElementById('select-white');
        const selectBlackEl = document.getElementById('select-black');

        const updateColorSelection = (isWhite) => {
            userColorIsWhite = isWhite;
            selectWhiteEl.classList.toggle('selected', isWhite);
            selectBlackEl.classList.toggle('selected', !isWhite);
        };

        selectWhiteEl.addEventListener('click', () => updateColorSelection(true));
        selectBlackEl.addEventListener('click', () => updateColorSelection(false));

        // Event Listeners para modos de jogo
        document.getElementById('btn-2v2-capa').addEventListener('click', () => iniciarJogoDamas('PVP'));
        document.getElementById('btn-bot-capa').addEventListener('click', () => iniciarJogoDamas('PVBOT'));
    }

    // Event Listener para o bot√£o de reiniciar (no modal de fim de jogo)
    document.getElementById('btn-reiniciar-damas').addEventListener('click', () => {
        // Volta para a tela de sele√ß√£o de modo/cor
        setupDamasInitial();
        esconderModalDamas();
    });

    // --- RENDERIZA√á√ÉO VISUAL DO TABULEIRO DAMAS ---

    // Retorna a classe de cor CSS para uma pe√ßa baseada no player e na escolha do usu√°rio
    function getPecaColorClass(pecaTipo) {
        // Se a pe√ßa for do JOGADOR_1 (voc√™)
        if (pecaTipo === JOGADOR_1 || pecaTipo === DAMA_1) {
            return userColorIsWhite ? 'peca-branca' : 'peca-preta';
        }
        // Se a pe√ßa for do JOGADOR_2 (oponente)
        if (pecaTipo === JOGADOR_2 || pecaTipo === DAMA_2) {
            return userColorIsWhite ? 'peca-preta' : 'peca-branca';
        }
        return '';
    }

    // Cria os elementos HTML e reflete o estado 'board' na tela
    function renderizarTabuleiro() {
        tabuleiroEl.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const casaEl = document.createElement('div');
                casaEl.classList.add('casa', (r + c) % 2 === 0 ? 'clara' : 'escura');
                casaEl.dataset.r = r;
                casaEl.dataset.c = c;

                // Adiciona o manipulador de clique apenas para casas escuras
                if ((r + c) % 2 !== 0) {
                    casaEl.addEventListener('click', handleCasaClick);
                }

                // Adiciona a pe√ßa, se houver
                const pecaTipo = board[r][c];
                if (pecaTipo !== VAZIO) {
                    const pecaEl = document.createElement('div');
                    pecaEl.classList.add('peca', getPecaColorClass(pecaTipo));

                    if (pecaTipo === DAMA_1 || pecaTipo === DAMA_2) {
                        pecaEl.classList.add('dama');
                    }
                    pecaEl.dataset.r = r;
                    pecaEl.dataset.c = c;
                    pecaEl.addEventListener('click', handlePecaClick);
                    casaEl.appendChild(pecaEl);
                }
                tabuleiroEl.appendChild(casaEl);
            }
        }
    }

    // Atualiza a exibi√ß√£o da pontua√ß√£o no placar
    function renderizarPontuacao() {
        scoreJ1El.textContent = pecasCapturadasJ1; // Voc√™
        scoreJ2El.textContent = pecasCapturadasJ2; // Advers√°rio
    }

    // Limpa os destaques de sele√ß√£o e movimentos v√°lidos
    function limparDestaques() {
        document.querySelectorAll('.selecionada, .movimento-valido').forEach(el => {
            el.classList.remove('selecionada', 'movimento-valido');
        });
    }

    // Atualiza o texto de status
    function atualizarStatus(msg = null) {
        const corJogadorAtual = (turnoAtual === JOGADOR_1) === userColorIsWhite ? 'Brancas' : 'Pretas';
        const nomeJogadorAtual = turnoAtual === JOGADOR_1 ? 'Voc√™' : (modoJogo === 'PVBOT' ? 'Bot' : 'Advers√°rio');
        const corStatus = (turnoAtual === JOGADOR_1) ? 'text-blue-600' : 'text-red-600';

        statusEl.classList.remove('text-blue-600', 'text-gray-700', 'text-red-600');

        let statusText;
        if (msg) {
             statusText = msg;
             statusEl.classList.add('text-gray-700');
        } else if (capturasObrigatorias.length > 0) {
            statusText = `Turno de ${nomeJogadorAtual} (${corJogadorAtual}). CAPTURA OBRIGAT√ìRIA!`;
        } else if (multiJumpPeca) {
            statusText = `Turno de ${nomeJogadorAtual} (${corJogadorAtual}). MULTI-CAPTURA!`;
        } else {
            statusText = `Turno de ${nomeJogadorAtual} (${corJogadorAtual}).`;
        }

        statusEl.textContent = statusText;
        statusEl.classList.add(corStatus);
    }

    // --- L√ìGICA DE MOVIMENTOS E REGRAS DAMAS ---

    // Retorna se uma pe√ßa √© uma Dama
    function isKing(pecaTipo) {
        return pecaTipo === DAMA_1 || pecaTipo === DAMA_2;
    }

    // Verifica se a pe√ßa √© do jogador atual
    function isTurnoDaPeca(pecaTipo) {
        return (turnoAtual === JOGADOR_1 && (pecaTipo === JOGADOR_1 || pecaTipo === DAMA_1)) ||
               (turnoAtual === JOGADOR_2 && (pecaTipo === JOGADOR_2 || pecaTipo === DAMA_2));
    }

    // Encontra TODAS as capturas poss√≠veis para a pe√ßa (r, c)
    function encontrarCapturasParaPeca(r, c, player) {
        const pecaTipo = board[r][c];
        if (pecaTipo === VAZIO) return [];

        const isDama = isKing(pecaTipo);
        const direcoes = isDama ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                             (player === JOGADOR_1 ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]); // J1 (em baixo) vai para cima (-1); J2 (em cima) vai para baixo (+1)

        const capturas = [];
        const oponente1 = player === JOGADOR_1 ? JOGADOR_2 : JOGADOR_1;
        const oponente2 = player === JOGADOR_1 ? DAMA_2 : DAMA_1;

        for (const [dr, dc] of direcoes) {
            const rMeio = r + dr;
            const cMeio = c + dc;
            const rDestino = r + 2 * dr;
            const cDestino = c + 2 * dc;

            if (rDestino >= 0 && rDestino < 8 && cDestino >= 0 && cDestino < 8) {
                const pecaMeio = board[rMeio][cMeio];
                const casaDestino = board[rDestino][cDestino];

                if ((pecaMeio === oponente1 || pecaMeio === oponente2) && casaDestino === VAZIO) {
                    capturas.push({
                        fromR: r, fromC: c,
                        toR: rDestino, toC: cDestino,
                        captureR: rMeio, captureC: cMeio
                    });
                }
            }
        }
        return capturas;
    }

    // Checa todas as capturas obrigat√≥rias para um jogador (chamado no in√≠cio do turno)
    function checkAllCaptures(player) {
        let allCaptures = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pecaTipo = board[r][c];
                if ((player === JOGADOR_1 && (pecaTipo === JOGADOR_1 || pecaTipo === DAMA_1)) ||
                    (player === JOGADOR_2 && (pecaTipo === JOGADOR_2 || pecaTipo === DAMA_2))) {
                    allCaptures = allCaptures.concat(encontrarCapturasParaPeca(r, c, player));
                }
            }
        }
        return allCaptures;
    }

    // Encontra movimentos simples v√°lidos para a pe√ßa (r, c)
    function encontrarMovimentosSimples(r, c, player) {
        const pecaTipo = board[r][c];
        const isDama = isKing(pecaTipo);
        const movimentos = [];

        const direcoes = isDama ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                             (player === JOGADOR_1 ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]);

        for (const [dr, dc] of direcoes) {
            const rDestino = r + dr;
            const cDestino = c + dc;

            if (rDestino >= 0 && rDestino < 8 && cDestino >= 0 && cDestino < 8) {
                if (board[rDestino][cDestino] === VAZIO) {
                    movimentos.push({ toR: rDestino, toC: cDestino });
                }
            }
        }
        return movimentos;
    }

    // Checa se uma pe√ßa deve ser promovida a Dama
    function checarPromocao(r, c) {
        const pecaTipo = board[r][c];
        if (pecaTipo === JOGADOR_1 && r === 0) { // J1 alcan√ßa a √∫ltima linha do oponente
            board[r][c] = DAMA_1;
        } else if (pecaTipo === JOGADOR_2 && r === 7) { // J2 alcan√ßa a √∫ltima linha do J1
            board[r][c] = DAMA_2;
        }
    }

    // Verifica se o jogo terminou
    function checarFimDeJogo() {
        let countJ1 = 0;
        let countJ2 = 0;

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pecaTipo = board[r][c];
                if (pecaTipo === JOGADOR_1 || pecaTipo === DAMA_1) countJ1++;
                if (pecaTipo === JOGADOR_2 || pecaTipo === DAMA_2) countJ2++;
            }
        }

        if (countJ1 === 0) return JOGADOR_2;
        if (countJ2 === 0) return JOGADOR_1;

        // Verifica se o jogador atual tem movimentos dispon√≠veis
        const player = turnoAtual;
        const allCaptures = checkAllCaptures(player);
        if (allCaptures.length > 0) return null; // Tem captura obrigat√≥ria

        let hasSimpleMove = false;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pecaTipo = board[r][c];
                if ((player === JOGADOR_1 && (pecaTipo === JOGADOR_1 || pecaTipo === DAMA_1)) ||
                    (player === JOGADOR_2 && (pecaTipo === JOGADOR_2 || pecaTipo === DAMA_2))) {
                    if (encontrarMovimentosSimples(r, c, player).length > 0) {
                        hasSimpleMove = true;
                        break;
                    }
                }
            }
            if (hasSimpleMove) break;
        }

        if (!hasSimpleMove) {
            return player === JOGADOR_1 ? JOGADOR_2 : JOGADOR_1; // Vencedor √© o oponente (por imobiliza√ß√£o)
        }

        return null; // O jogo continua
    }

    // Mostra o modal de fim de jogo
    function mostrarModalDamas(vencedor) {
        isGameOver = true;
        const nomeVencedor = vencedor === JOGADOR_1 ? 'Voc√™' : (modoJogo === 'PVBOT' ? 'O Bot' : 'O Advers√°rio');
        const corVencedor = (vencedor === JOGADOR_1) === userColorIsWhite ? 'Brancas' : 'Pretas';
        const corModal = vencedor === JOGADOR_1 ? 'text-blue-600' : 'text-red-600';

        modalTituloEl.textContent = `FIM DE JOGO!`;
        modalTituloEl.classList.remove('text-blue-600', 'text-red-600');
        modalTituloEl.classList.add(corModal);
        modalMensagemEl.textContent = `${nomeVencedor} (${corVencedor}) venceu! (${pecasCapturadasJ1} x ${pecasCapturadasJ2})`;

        modalEl.classList.remove('hidden');
        modalEl.classList.add('flex');
    }

    // Esconde o modal de fim de jogo
    function esconderModalDamas() {
        modalEl.classList.add('hidden');
        modalEl.classList.remove('flex');
    }

    // Lida com o clique na pe√ßa
    function handlePecaClick(event) {
        if (isGameOver || !modoJogo) return;
        event.stopPropagation();

        const r = parseInt(event.target.dataset.r);
        const c = parseInt(event.target.dataset.c);
        const pecaTipo = board[r][c];

        if (!isTurnoDaPeca(pecaTipo)) {
            atualizarStatus(`N√£o √© seu turno!`);
            return;
        }

        // Se for o turno do Bot, ignora
        if (modoJogo === 'PVBOT' && turnoAtual === JOGADOR_2) return;

        limparDestaques();

        // 1. Enfor√ßar Multi-Captura
        if (multiJumpPeca && (multiJumpPeca.r !== r || multiJumpPeca.c !== c)) {
            atualizarStatus("Voc√™ deve continuar a captura com a mesma pe√ßa!");
            // Destaque novamente a pe√ßa que deve continuar a captura
            const currentMultiPecaEl = tabuleiroEl.querySelector(`.peca[data-r="${multiJumpPeca.r}"][data-c="${multiJumpPeca.c}"]`);
            if (currentMultiPecaEl) currentMultiPecaEl.classList.add('selecionada');
            return;
        }

        // 2. Enfor√ßar Captura Obrigat√≥ria Global
        if (capturasObrigatorias.length > 0) {
            const capturasParaEstaPeca = capturasObrigatorias.filter(cap => cap.fromR === r && cap.fromC === c);

            if (capturasParaEstaPeca.length > 0) {
                pecaSelecionada = { r, c };
                event.target.classList.add('selecionada');

                capturasParaEstaPeca.forEach(cap => {
                    const casaDestinoEl = tabuleiroEl.querySelector(`.casa[data-r="${cap.toR}"][data-c="${cap.toC}"]`);
                    if (casaDestinoEl) casaDestinoEl.classList.add('movimento-valido');
                });
                atualizarStatus();
            } else {
                pecaSelecionada = null;
                atualizarStatus(`H√° uma CAPTURA OBRIGAT√ìRIA! Selecione a pe√ßa que pode capturar.`);
            }

        } else {
            // Permite movimento simples
            pecaSelecionada = { r, c };
            event.target.classList.add('selecionada');

            const movimentosValidos = encontrarMovimentosSimples(r, c, turnoAtual);

            movimentosValidos.forEach(m => {
                const casaDestinoEl = tabuleiroEl.querySelector(`.casa[data-r="${m.toR}"][data-c="${m.toC}"]`);
                if (casaDestinoEl) casaDestinoEl.classList.add('movimento-valido');
            });
            atualizarStatus();
        }
    }

    // Lida com o clique na casa (destino de movimento)
    function handleCasaClick(event) {
        if (isGameOver || !pecaSelecionada) return;

        const toR = parseInt(event.target.dataset.r);
        const toC = parseInt(event.target.dataset.c);
        const fromR = pecaSelecionada.r;
        const fromC = pecaSelecionada.c;

        limparDestaques();

        let shouldEndTurn = true;

        // 1. Tentar Captura (Prioridade m√°xima)
        const capturaValida = capturasObrigatorias.find(cap =>
            cap.fromR === fromR && cap.fromC === fromC && cap.toR === toR && cap.toC === toC
        );

        if (capturasObrigatorias.length > 0) {

            if (capturaValida) {
                executarMovimento(capturaValida.fromR, capturaValida.fromC, capturaValida.toR, capturaValida.toC, capturaValida.captureR, capturaValida.captureC);

                const novasCapturas = encontrarCapturasParaPeca(capturaValida.toR, capturaValida.toC, turnoAtual);

                if (novasCapturas.length > 0) {
                    shouldEndTurn = false;
                    pecaSelecionada = { r: capturaValida.toR, c: capturaValida.toC };
                    capturasObrigatorias = novasCapturas;
                    multiJumpPeca = pecaSelecionada;

                    // Redesenha para aplicar o destaque de sele√ß√£o e movimento
                    renderizarTabuleiro();
                    const pecaEl = tabuleiroEl.querySelector(`.peca[data-r="${pecaSelecionada.r}"][data-c="${pecaSelecionada.c}"]`);
                    if (pecaEl) pecaEl.classList.add('selecionada');

                    novasCapturas.forEach(cap => {
                        const casaDestinoEl = tabuleiroEl.querySelector(`.casa[data-r="${cap.toR}"][data-c="${cap.toC}"]`);
                        if (casaDestinoEl) casaDestinoEl.classList.add('movimento-valido');
                    });

                } else {
                    multiJumpPeca = null;
                }

            } else {
                atualizarStatus(`Movimento inv√°lido. Voc√™ deve completar a CAPTURA OBRIGAT√ìRIA.`);
                pecaSelecionada = null;
                return;
            }

        // 2. Tentar Movimento Simples (se n√£o houver captura obrigat√≥ria)
        } else {
            const movimentosValidos = encontrarMovimentosSimples(fromR, fromC, turnoAtual);
            const moveValido = movimentosValidos.find(m => m.toR === toR && m.toC === toC);

            if (moveValido) {
                executarMovimento(fromR, fromC, toR, toC);
            } else {
                atualizarStatus("Movimento inv√°lido. Selecione um destino verde.");
                pecaSelecionada = null;
                return;
            }
        }

        // Finaliza o turno e troca de jogador, se n√£o for multi-salto
        pecaSelecionada = null;
        if (shouldEndTurn) {
            proximoTurno();
        } else {
            atualizarStatus();
        }
    }

    // Executa a altera√ß√£o no estado do tabuleiro (e na DOM)
    function executarMovimento(fromR, fromC, toR, toC, captureR = null, captureC = null) {
        board[toR][toC] = board[fromR][fromC];
        board[fromR][fromC] = VAZIO;

        if (captureR !== null) {
            const pecaCapturadaTipo = board[captureR][captureC];
            board[captureR][captureC] = VAZIO;

            // Contabiliza a pe√ßa capturada
            if (pecaCapturadaTipo === JOGADOR_2 || pecaCapturadaTipo === DAMA_2) {
                pecasCapturadasJ1++; // J1 (Voc√™) capturou
            } else if (pecaCapturadaTipo === JOGADOR_1 || pecaCapturadaTipo === DAMA_1) {
                pecasCapturadasJ2++; // J2 (Advers√°rio/Bot) capturou
            }
            renderizarPontuacao();
        }

        checarPromocao(toR, toC);
        renderizarTabuleiro();
    }

    // Passa para o pr√≥ximo jogador
    function proximoTurno() {
        const vencedor = checarFimDeJogo();
        if (vencedor !== null) {
            mostrarModalDamas(vencedor);
            return;
        }

        turnoAtual = turnoAtual === JOGADOR_1 ? JOGADOR_2 : JOGADOR_1;

        capturasObrigatorias = checkAllCaptures(turnoAtual);
        multiJumpPeca = null;

        atualizarStatus();

        if (modoJogo === 'PVBOT' && turnoAtual === JOGADOR_2) {
            setTimeout(fazerJogadaBot, 1000);
        }
    }

    // --- L√ìGICA DO BOT (IA SIMPLES) DAMAS ---

    // Fun√ß√£o auxiliar para fazer o pr√≥ximo salto do bot
    function botMultiJump(r, c) {
        // Encontra capturas (saltos) a partir da nova posi√ß√£o (r, c)
        const capturas = encontrarCapturasParaPeca(r, c, JOGADOR_2);

        if (capturas.length > 0) {
            // Escolhe uma captura aleat√≥ria para continuar a sequ√™ncia
            const jogada = capturas[Math.floor(Math.random() * capturas.length)];

            executarMovimento(jogada.fromR, jogada.fromC, jogada.toR, jogada.toC, jogada.captureR, jogada.captureC);

            // Continua a cadeia de saltos ap√≥s um pequeno atraso
            setTimeout(() => botMultiJump(jogada.toR, jogada.toC), 750);
        } else {
            // Fim da cadeia de saltos, passa o turno
            proximoTurno();
        }
    }

    function fazerJogadaBot() {
        if (turnoAtual !== JOGADOR_2 || modoJogo !== 'PVBOT' || isGameOver) return;

        const player = JOGADOR_2;
        let todosOsMovimentos = [];

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pecaTipo = board[r][c];
                if (pecaTipo === player || pecaTipo === DAMA_2) {
                    const capturas = encontrarCapturasParaPeca(r, c, player);

                    if (capturas.length > 0) {
                        capturas.forEach(cap => {
                            cap.isCapture = true;
                            todosOsMovimentos.push(cap);
                        });
                    } else if (capturasObrigatorias.length === 0) {
                        const moves = encontrarMovimentosSimples(r, c, player);
                        moves.forEach(m => {
                            m.fromR = r; m.fromC = c;
                            m.isCapture = false;
                            todosOsMovimentos.push(m);
                        });
                    }
                }
            }
        }

        if (todosOsMovimentos.length === 0) {
             proximoTurno();
             return;
        }

        let jogadasDeCaptura = todosOsMovimentos.filter(m => m.isCapture);
        let jogadasParaMover = todosOsMovimentos.filter(m => !m.isCapture);

        let jogada;
        if (jogadasDeCaptura.length > 0) {
            // Prioriza capturas
            jogada = jogadasDeCaptura[Math.floor(Math.random() * jogadasDeCaptura.length)];
        } else if (jogadasParaMover.length > 0) {
            // Faz movimento simples aleat√≥rio
            jogada = jogadasParaMover[Math.floor(Math.random() * jogadasParaMover.length)];
        } else {
            proximoTurno();
            return;
        }

        // Executa o movimento inicial
        executarMovimento(jogada.fromR, jogada.fromC, jogada.toR, jogada.toC, jogada.captureR, jogada.captureC);

        // Verifica se houve captura e se pode continuar (multi-salto)
        if (jogada.isCapture) {
            setTimeout(() => botMultiJump(jogada.toR, jogada.toC), 750);
        } else {
            // Passa o turno
            proximoTurno();
        }
    }
</script>
